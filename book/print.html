<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The PLCnext Runtime</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/first-edition.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The PLCnext Runtime</a></li><li class="chapter-item expanded affix "><a href="edition-notice.html">Copyright Notice</a></li><li class="chapter-item expanded affix "><a href="acknowledgments.html">Acknowledgments</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-ip-address.html"><strong aria-hidden="true">1.1.</strong> Setting the IP Address</a></li><li class="chapter-item expanded "><a href="ch01-02-shell-session.html"><strong aria-hidden="true">1.2.</strong> Starting a Shell Session</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-world.html"><strong aria-hidden="true">1.3.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-04-installing-a-software-development-kit.html"><strong aria-hidden="true">1.4.</strong> Installing a Software Development Kit</a></li><li class="chapter-item expanded "><a href="ch01-05-hello-again-world.html"><strong aria-hidden="true">1.5.</strong> Hello Again, World!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-operating-system.html"><strong aria-hidden="true">2.</strong> Operating System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-security.html"><strong aria-hidden="true">2.1.</strong> Security</a></li><li class="chapter-item expanded "><a href="ch02-02-users-and-privileges.html"><strong aria-hidden="true">2.2.</strong> Users and Privileges</a></li><li class="chapter-item expanded "><a href="ch02-03-setting-the-time.html"><strong aria-hidden="true">2.3.</strong> Setting the Time</a></li><li class="chapter-item expanded "><a href="ch02-04-firmware.html"><strong aria-hidden="true">2.4.</strong> Firmware</a></li><li class="chapter-item expanded "><a href="ch02-05-disk-partitions.html"><strong aria-hidden="true">2.5.</strong> Disk Partitions</a></li><li class="chapter-item expanded "><a href="ch02-06-file-system.html"><strong aria-hidden="true">2.6.</strong> File System</a></li><li class="chapter-item expanded "><a href="ch02-07-installing-software.html"><strong aria-hidden="true">2.7.</strong> Installing Software</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-plcnext-runtime.html"><strong aria-hidden="true">3.</strong> PLCnext Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-controlling-the-plcnext-runtime.html"><strong aria-hidden="true">3.1.</strong> Controlling the PLCnext Runtime</a></li><li class="chapter-item expanded "><a href="ch03-02-diagnosing-problems.html"><strong aria-hidden="true">3.2.</strong> Diagnosing Problems</a></li><li class="chapter-item expanded "><a href="ch03-03-plcnext-runtime-components.html"><strong aria-hidden="true">3.3.</strong> PLCnext Runtime Components</a></li><li class="chapter-item expanded "><a href="ch03-04-component-instances.html"><strong aria-hidden="true">3.4.</strong> Component Instances</a></li><li class="chapter-item expanded "><a href="ch03-05-disabling-features.html"><strong aria-hidden="true">3.5.</strong> Disabling Features</a></li><li class="chapter-item expanded "><a href="ch03-06-rsc-services.html"><strong aria-hidden="true">3.6.</strong> RSC Services</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-extension-components.html"><strong aria-hidden="true">4.</strong> Extension Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-simple-component.html"><strong aria-hidden="true">4.1.</strong> Simple Extension Component</a></li><li class="chapter-item expanded "><a href="ch04-02-library-singleton.html"><strong aria-hidden="true">4.2.</strong> Component Library Singleton</a></li><li class="chapter-item expanded "><a href="ch04-03-component-methods.html"><strong aria-hidden="true">4.3.</strong> Component Methods</a></li><li class="chapter-item expanded "><a href="ch04-04-using-rsc-services.html"><strong aria-hidden="true">4.4.</strong> Using RSC Services</a></li><li class="chapter-item expanded "><a href="ch04-05-worker-threads.html"><strong aria-hidden="true">4.5.</strong> Worker Threads</a></li><li class="chapter-item expanded "><a href="ch04-06-creating-gds-variables-1.html"><strong aria-hidden="true">4.6.</strong> Creating GDS variables - Part 1</a></li><li class="chapter-item expanded "><a href="ch04-07-plcnext-cli.html"><strong aria-hidden="true">4.7.</strong> PLCnext CLI</a></li><li class="chapter-item expanded "><a href="ch04-08-creating-gds-variables-2.html"><strong aria-hidden="true">4.8.</strong> Creating GDS variables - Part 2</a></li><li class="chapter-item expanded "><a href="ch04-09-connecting-gds-variables.html"><strong aria-hidden="true">4.9.</strong> Connecting GDS Variables</a></li><li class="chapter-item expanded "><a href="ch04-10-interactive-course.html"><strong aria-hidden="true">4.10.</strong> Interactive Course</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-real-time-programming.html"><strong aria-hidden="true">5.</strong> Real Time Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-cpp-programs.html"><strong aria-hidden="true">5.1.</strong> C++ Programs</a></li><li class="chapter-item expanded "><a href="ch05-02-real-time-guidelines.html"><strong aria-hidden="true">5.2.</strong> Real-time C++ Programming Guidelines</a></li><li class="chapter-item expanded "><a href="ch05-03-building-and-deploying.html"><strong aria-hidden="true">5.3.</strong> Building and Deploying a Real-time C++ Application</a></li><li class="chapter-item expanded "><a href="ch05-04-iec-programs.html"><strong aria-hidden="true">5.4.</strong> IEC 61131-3 Programs</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-configuring-io.html"><strong aria-hidden="true">6.</strong> Configuring I/O</a></li><li class="chapter-item expanded "><a href="ch07-00-other-tools.html"><strong aria-hidden="true">7.</strong> Other Programming Tools</a></li><li class="chapter-item expanded "><a href="ch08-00-extension-processes.html"><strong aria-hidden="true">8.</strong> Extension Processes</a></li><li class="chapter-item expanded "><a href="ch09-00-what-next.html"><strong aria-hidden="true">9.</strong> What Next</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-the-big-picture.html"><strong aria-hidden="true">9.1.</strong> The Big Picture</a></li><li class="chapter-item expanded "><a href="ch09-02-get-involved.html"><strong aria-hidden="true">9.2.</strong> Get Involved!</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">10.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-programming-resources.html"><strong aria-hidden="true">10.1.</strong> A - Programming Resources</a></li><li class="chapter-item expanded "><a href="appendix-02-list-of-rsc-services.html"><strong aria-hidden="true">10.2.</strong> B - RSC Services</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The PLCnext Runtime</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="text-align:center">
<h1 id="the-plcnext-runtime"><a class="header" href="#the-plcnext-runtime">The PLCnext Runtime</a></h1>
<br/>
<br/>
<!--<p><img src="img/plcnext-runtime.gif" alt="PLCnext Runtime logo" style="width:300px;height:300px;"></p>-->
<br/>
<h2 id="by-martin-boers"><a class="header" href="#by-martin-boers"><i>by Martin Boers</i></a></h2>
<br/>
</div>
<div style="break-before: page; page-break-before: always;"></div><p>The PLCnext Runtime © 2020-2021 Martin Boers</p>
<p>PLCnext Technology, PLCnext Engineer, PLCnext Store and Proficloud are registered trade marks of Phoenix Contact GmbH &amp; Co. KG.</p>
<p>This book is not produced, supported or endorsed by Phoenix Contact GmbH &amp; Co. KG or any of its associated companies.</p>
<p>While every effort has been made to ensure the accuracy of material in this book, the author accepts no responsibility for any errors or omissions.</p>
<p>The content of this book is subject to change without notice.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h1>
<p>The following people have provided invaluable support in the creation of this book:</p>
<ul>
<li>
<p><a href="https://github.com/idzm">Dzmitry Ivaniuk</a> at <a href="https://github.com/savushkin-r-d">Savushkin R&amp;D</a>.</p>
</li>
<li>
<p>Everyone in the PLCnext Runtime support team at Phoenix Contact Electronics, including Frank Walde, Eduard Münz, Oliver Warneke, Heiko Hüllwegen and Gundula Breder.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <em>The PLCnext Runtime</em>, an introductory book about programming on the PLCnext Control platform.</p>
<h2 id="what-is-plcnext-control"><a class="header" href="#what-is-plcnext-control">What Is PLCnext Control?</a></h2>
<p>PLCnext Control refers to a range of embedded computers from Phoenix Contact, which are designed for automating industrial processes. These controllers share some characteristics with popular single-board computers, but PLCnext Control devices includes features that make them particularly suitable for industrial applications.</p>
<p>The PLCnext Control range currently includes the following hardware variants from the AXC<sup>1</sup>, EPC<sup>2</sup>, RFC<sup>3</sup> and BPC ranges:</p>
<ul>
<li><a href="http://www.phoenixcontact.com/product/1151412">AXC F 1152</a> (ARM® Cortex®-A9 2x 800 MHz)</li>
<li><a href="http://www.phoenixcontact.com/product/2404267">AXC F 2152</a> (ARM® Cortex®-A9 2x 800 MHz, PCIe® connector)</li>
<li><a href="http://www.phoenixcontact.com/product/1069208">AXC F 3152</a> (Intel® Atom™ x5-E3930 1.3 GHz Dual Core)</li>
<li><a href="http://www.phoenixcontact.com/product/1185416">EPC 1502</a> (Intel® Celeron® N3350 1.10/2.40 GHz, 2GB RAM)</li>
<li><a href="http://www.phoenixcontact.com/product/1185423">EPC 1522</a> (Intel® Celeron® N3350 1.10/2.40 GHz, 4GB RAM, 2x DB9 COM ports)</li>
<li><a href="http://www.phoenixcontact.com/product/1051328">RFC 4072S</a> (Intel® Core™ i5-6300U 2x 2.4 GHz + separate safety processors)</li>
<li><a href="http://www.phoenixcontact.com/product/1246285">BPC 9102S</a> (Intel® Core™ i7-10700TE 8x 2.4 GHz + separate safety processors)</li>
</ul>
<p>Each of these hardware platforms runs custom firmware that is based on Linux kernel version 5.4 with the <a href="https://wiki.linuxfoundation.org/realtime/start">PREEMT-RT patch</a>.</p>
<h2 id="who-plcnext-control-is-for"><a class="header" href="#who-plcnext-control-is-for">Who PLCnext Control Is For</a></h2>
<p>PLCnext Control is ideal for software and systems engineers involved in the automation of industrial processes.</p>
<p>Controllers from the PLCnext Control range can perform the role of traditional PLCs<sup>4</sup>, however they also include features that will be familiar to software engineers with a more general programming background.</p>
<h3 id="iec-61131-3-software-developers"><a class="header" href="#iec-61131-3-software-developers">IEC 61131-3 Software Developers</a></h3>
<p>Traditional PLCs generally can be programmed using any language defined by the IEC 61131-3 standard. Controllers from the PLCnext Control range are no different. For these developers, Phoenix Contact provides <a href="http://www.phoenixcontact.com/product/1046008"><em>PLCnext Engineer</em></a> software.</p>
<h3 id="simulink-software-developers"><a class="header" href="#simulink-software-developers">Simulink® Software Developers</a></h3>
<p>Simulink® is software for graphical, model-based development of dynamic systems. Simulink® models can be integrated into the PLCnext Engineer development environment using the <a href="http://www.phoenixcontact.com/product/1326100"><em>PLCnext Target for Simulink</em></a> software add-on.</p>
<h3 id="software-engineers-with-experience-in-cc-rust-c-java-python-javascript-html5-go-etc"><a class="header" href="#software-engineers-with-experience-in-cc-rust-c-java-python-javascript-html5-go-etc">Software engineers with experience in C/C++, Rust, C#, Java, Python, Javascript, HTML5, Go, etc</a></h3>
<p>Custom software applications written in any popular programming language can be run on the controller. These applications can make use of PLCnext runtime services if required.</p>
<h3 id="systems-integrators-and-network-administrators"><a class="header" href="#systems-integrators-and-network-administrators">Systems integrators and network administrators</a></h3>
<p>It is possible to simply install and configure pre-built applications on a PLCnext Control device, without any software engineering effort.</p>
<h3 id="project-teams-with-some-or-all-of-the-above-skills"><a class="header" href="#project-teams-with-some-or-all-of-the-above-skills">Project teams with some or all of the above skills</a></h3>
<p>PLCnext Control devices includes unique features - such as the Global Data Space (GDS) and the Execution and Synchronisation Manager (ESM) - that make it possible to combine components written in different languages into a single project.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book Is For</a></h2>
<p>This book is aimed at software developers who want to extend the functionality of a PLCnext Control device with their own software. The book contains program examples and references in a number of popular languages, but generally uses C++ to demonstrate the features of PLCnext Control. C++ is used because PLCnext Control provides a C++ programming framework, and many of the open-source projects that are suitable for PLCnext Control projects are also written in C++. However, software engineers with other programming skills should be able to apply the principles found in this book to their language of choice. For these programmers, appendix A gives references to language-specific resources.</p>
<p>This book does not cover PLCnext Engineer or programming in IEC 61131-3 languages, and in fact it is not necessary to read this book in order to become proficient in PLCnext Control programming using PLCnext Engineer. For IEC 61131-3 programmers, there are other resources from Phoenix Contact that will help you get started with PLCnext Engineer.</p>
<p>For systems integrators who don't want to write their own software, but who want to install and configure third-party software on a PLCnext Control - you will be most interested in Chapters 1 and 2.</p>
<p>For systems and network administrators who will be managing PLCnext Control devices - you will also find Chapters 1 and 2 useful.</p>
<h2 id="what-you-will-need"><a class="header" href="#what-you-will-need">What You Will Need</a></h2>
<p>Obviously, you will need a controller from the PLCnext Control range. These are available for purchase from your local Phoenix Contact subsidiary, or from a number of online automation resellers. You will need to power the controller with a 24 VDC supply. A good option is the <a href="http://www.phoenixcontact.com/product/1188165">PLCnext Technology Starter Kit</a>, which includes an AXC F 2152 controller, a 24 VDC power supply unit with pre-wired mains plug, and digital and analog input/output (I/O) modules.</p>
<p>All sections of this book apply to AXC F 1152 and 2152 devices, and most sections also apply to other PLCnext Control devices.</p>
<p>A PLCnext Control device is a <em>target</em> (in embedded programming terminology), and it requires a <em>host</em>. This book uses Debian 11 as the host machine, but any popular Linux distribution - or even Microsoft Windows - should also work. Windows commands are not shown in this book, so Windows users should consider installing <a href="https://learn.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux</a> to work along with this book.</p>
<p>The host machine must be connected to the internet. The host machine requires certain software development tools to be installed, and these will be described in the relevant sections of this book.</p>
<p>The controller must be connected to a local area network with access to both the internet and the host machine. Note that the controller does not include a wireless network adapter.</p>
<p>A knowledge of Ethernet networking would also be beneficial. The book &quot;<a href="http://plcnext-runtime.com/downloads/Ethernet_Basics_rev2_en.pdf">Ethernet Basics</a>&quot; by Phoenix Contact is recommended for this purpose.</p>
<blockquote>
<p>Throughout this book, the PLCnext Control hardware will be referred to as either <em>PLCnext Control device</em>, or <em>controller</em>, or <em>target</em>. In this book, these terms are used interchangeably. Controllers from other manufacturers are often referred to with the term  <em>PLC</em>, but in this book the term <em>PLC</em> will only be used to refer to those firmware components on the controller that implement real-time automation functions.</p>
</blockquote>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to Use This Book</a></h2>
<p>This book should be read from front to back. It is not intended to be an exhaustive reference; that is provided by the <a href="https://www.plcnext.help/te/About/Home.htm">PLCnext Technology Info Centre</a>. Instead, this book will draw on material in relevant sections of the Info Center, and elsewhere, to build up the readers knowledge in incremental steps.</p>
<p>Chapter 1 explains how to get started with a PLCnext Control device, from setting the IP address to writing your first &quot;Hello, World!&quot; programs in Python, C++ and Rust. Chapter 2 looks at some basic features of the Linux operating system (firmware) that runs on PLCnext Control devices. Chapter 3 introduces the PLCnext runtime by exploring the complete set of PLCnext runtime components that are installed with the firmware.</p>
<p>In Chapter 4, you will write your own PLCnext runtime extension component in C++. You will learn how extension components can use PLCnext runtime services, how they can provide their own services to other components, and how they can exchange data with other components through the global data space.</p>
<p>Chapter 5 introduces real-time programming on PLCnext Control devices. You will write a C++ program and configure the execution and synchronisation manager to run the program in a real-time PLC task. In Chapter 6 you will learn how a real-time program can read and write process data on Axioline I/O modules attached to the controller.</p>
<p>Chapter 7 looks at some additional tools that can help with PLCnext runtime programming.</p>
<p>Chapter 8 is for developers who want to port an existing runtime to a PLCnext Control device, or write a completely new runtime. You will learn how external runtimes can access the I/O that is connected to the controller, and how they can continue to utilise services provided by the PLCnext runtime.</p>
<p>A glossary of terms used in this book is available in the <a href="https://www.plcnext.help/te/About/Home.htm?agt=glossary">PLCnext Technology Info Center</a>.</p>
<blockquote>
<h3 id="command-line-notation"><a class="header" href="#command-line-notation">Command Line Notation</a></h3>
<p>Throughout this book, you will see commands that must be entered into a terminal on either the host or the target.</p>
<p>Commands in a terminal on the host all start with <code>$</code> (you don’t need to enter the <code>$</code> character).</p>
<p>Commands in a terminal on the target all start with <code>#</code> (you don’t need to enter the <code>#</code> character).</p>
<p>Commands in a terminal running the python interpreter all start with <code>&gt;&gt;&gt;</code> (you don’t need to enter the <code>&gt;&gt;&gt;</code> characters).</p>
<p>Lines that don’t start with <code>$</code>, <code>#</code> or <code>&gt;&gt;&gt;</code> typically show the output of the previous command.</p>
</blockquote>
<h2 id="versions"><a class="header" href="#versions">Versions</a></h2>
<p>This book will be kept up to date with the latest release of PLCnext Control firmware. As soon as a new version of PLCnext Control firmware is released, the book source code will be tagged with the version number of the firmware that has just been superseded.</p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>The source files used to generate this book can be found on <a href="https://github.com/martinboers/plcnext-book/tree/master/src">GitHub</a>.</p>
<hr />
<p><sup>1</sup> <em>AXC</em> is short for <em>Axioline Controller</em>, indicating that the controller has a dedicated hardware interface to connect directly to the Axioline range of I/O modules. <em>Axioline</em> is derived from the terms <em>AutomationWorx</em> (AX), a brand name used by Phoenix Contact, and <em>I/O</em>, meaning <em>Input/Output</em>. The term <em>line</em> can be taken to refer to a line of products, but in this case it was inherited from an earlier range of Phoenix Contact products called <em>Inline</em>. The letter &quot;F&quot; after &quot;AXC&quot; is used to distinguish these devices from earlier Axioline controllers, but otherwise has no meaning.</p>
<p><sup>2</sup> <em>EPC</em> is short for <em>Edge Personal Computer</em>. EPCs combine real-time PLC features with popular Industrial Internet of Things (IIoT) applications like <a href="https://nodered.org/">Node-RED</a> and <a href="https://www.influxdata.com/">InfluxDB</a>. EPCs are designed for industrial <a href="https://en.wikipedia.org/wiki/Edge_computing">Edge computing</a> applications.</p>
<p><sup>3</sup> <em>RFC</em> is short for <em>Remote Field Controller</em>. Unlike Axioline controllers, RFCs can only control <em>remote</em> I/O modules over a <em>field bus</em> like Profinet.</p>
<p><sup>4</sup> <em>PLC</em> is short for <a href="https://en.wikipedia.org/wiki/Programmable_logic_controller"><em>Programmable Logic Controller</em></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This chapter includes:</p>
<ul>
<li>
<p>Setting the controller's IP address</p>
</li>
<li>
<p>Starting a shell session</p>
</li>
<li>
<p>Writing a Python program that prints <code>Hello, world!</code></p>
</li>
<li>
<p>Installing a software development kit</p>
</li>
<li>
<p>Writing C++ and Rust programs that print <code>Hello, world!</code></p>
</li>
<li>
<p>Updating the firmware</p>
</li>
<li>
<p>Exploring the file system</p>
</li>
<li>
<p>Installing software</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setting-the-ip-address"><a class="header" href="#setting-the-ip-address">Setting the IP Address</a></h2>
<p>Once you have assembled <a href="ch00-00-introduction.html#what-you-will-need">everything you need to get started</a>, your PLCnext Control device will be powered up and plugged in to an Ethernet network with access to the internet. On <strong>AXC F 1152</strong> and <strong>AXC F 2152</strong> PLCnext Control devices it doesn't matter which of the two Ethernet ports are used; these are switched internally.</p>
<p>The factory default IP address of every PLCnext Control device is 192.168.1.10/24, but you will probably want to change this to something that suits your local network.</p>
<blockquote>
<p>This section shows how to change the IP address of the PLCnext Control device from the default value. In the remainder of this book, all examples will use the default IP address (192.168.1.10).</p>
</blockquote>
<p>Here are some possible ways to change the IP address of the PLCnext Control device:</p>
<h3 id="use-netnames"><a class="header" href="#use-netnames">Use netnames</a></h3>
<p>Netnames is a utility from Phoenix Contact that assists with the management of <a href="https://www.profibus.com/technology/profinet/">Profinet</a> devices. Netnames is available for <a href="http://plcnext-runtime.com/downloads/netnames/linux-x64/netnames">Linux 64 bit</a> and <a href="http://www.phoenixcontact.com/qr/2316390/softw">Windows</a> operating systems. The remainder of this section uses the Linux version of Netnames.</p>
<p>Firstly, make sure that netnames can be executed. From the <code>netnames</code> installation directory, run the following command:</p>
<pre><code class="language-text">$ chmod a+x netnames
</code></pre>
<p>By default, each PLCnext Control device acts as a Profinet device, and so can be assigned an IP address using <code>netnames</code>.</p>
<p>Run the following command, substituting <code>eth0</code> with the name of your Ethernet adapter. You should get a response similar to the one shown.</p>
<pre><code class="language-text">$ sudo ./netnames -i eth0 -c identify
axc-f-2152-1   AXC F 2152   00B0 0142 00:A0:45:A0:09:D8   192.168.1.10   255.255.255.0   0.0.0.0
</code></pre>
<p>The MAC address and current IP address details of the PLCnext Control device are shown in the response.</p>
<p>If you get no response, make sure the name of the Ethernet adapter is correct. Also, be aware that the <a href="https://profinetuniversity.com/naming-addressing/profinet-dcp/">Discovery and Configuration Protocol</a> (DCP) used by <code>netnames</code> is a link layer protocol, and so is not routable.</p>
<p>The IP address, subnet mask and default gateway can be changed using a command similar to the following:</p>
<pre><code class="language-text">$ sudo ./netnames -i eth0 -c setip -m 00:A0:45:A0:09:D8 -ip 192.168.178.10 -sm 255.255.255.0 -sg 192.168.178.1
Device responded: OK
</code></pre>
<p>Obviously the above command will need to include parameters that suit your own device and network. The IP address of the device should be in the same subnet as the host, and the default gateway should give the device access to the internet.</p>
<p>Your device should now be accessible from your host machine, which can be verified using <code>ping</code>:</p>
<pre><code class="language-text">$ ping -c 3 192.168.178.10
PING 192.168.178.10 (192.168.178.10) 56(84) bytes of data.
64 bytes from 192.168.178.10: icmp_seq=1 ttl=64 time=5.73 ms
64 bytes from 192.168.178.10: icmp_seq=2 ttl=64 time=4.87 ms
64 bytes from 192.168.178.10: icmp_seq=3 ttl=64 time=18.4 ms

--- 192.168.178.10 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2010ms
rtt min/avg/max/mdev = 4.877/9.690/18.464/6.214 ms
</code></pre>
<h3 id="use-the-display-rfc-only"><a class="header" href="#use-the-display-rfc-only">Use the Display (RFC only)</a></h3>
<p>RFC controllers come with an integrated touch-screen display, which can be used to set the controller's IP address.</p>
<h3 id="use-plcnext-engineer"><a class="header" href="#use-plcnext-engineer">Use PLCnext Engineer</a></h3>
<p>For Windows users, it is also possible to set the IP address of the PLCnext Control device using <a href="http://phoenixcontact.com/product/1046008">PLCnext Engineer</a> software. Refer to the guide &quot;<a href="https://www.plcnext.help/te/PLCnext_Engineer/Getting_started_with_PLCnext_Engineer.htm">Getting started with PLCnext Engineer</a>&quot; for instructions on how to do this.</p>
<h3 id="edit-the-interfaces-file"><a class="header" href="#edit-the-interfaces-file">Edit the interfaces file</a></h3>
<p>Once the device is accessible over the network via <code>ssh</code> (for example), it is possible to change the IP address of the device by editing the file <code>/etc/network/interfaces</code> directly on the device.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="starting-a-shell-session"><a class="header" href="#starting-a-shell-session">Starting a Shell Session</a></h2>
<p>The PLCnext Control device is running a secure shell (ssh) daemon so, once the device is accessible on the local area network, you can go ahead and open a shell session on the device from the host:</p>
<pre><code class="language-text">$ ssh admin@192.168.1.10
The authenticity of host '192.168.1.10 (192.168.1.10)' can't be established.
ECDSA key fingerprint is SHA256:uUhWsqX6TQy/KDZ4rdydja8zws7zCBLF5CI2/wm5owQ.
Are you sure you want to continue connecting (yes/no)?
</code></pre>
<p>You are requesting to log on to the PLC as the user <em>admin</em>. This user is set up by default on every PLCnext Control. The warning about the authenticity of the host is normal when using <code>ssh</code> to connect to a device for the first time. By answering <code>yes</code> to the question, the following appears:</p>
<pre><code class="language-text">Warning: Permanently added '192.168.1.10' (ECDSA) to the list of known hosts.
admin@192.168.1.10's password:
</code></pre>
<p>... and after entering the default password (printed on the housing of the PLC), the PLC's command prompt will appear:</p>
<pre><code class="language-text">admin@axcf2152:~$
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>Let's write our first PLCnext Control program!</p>
<h3 id="your-first-program"><a class="header" href="#your-first-program">Your First Program</a></h3>
<p>Every PLCnext Control device comes with Python already installed.</p>
<pre><code class="language-text"># python3
Python 3.7.2 (default, Nov 12 2019, 23:37:48)
[GCC 8.3.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
</code></pre>
<p>Here, you can see the version of Python that is installed on the device. The Python command prompt <code>&gt;&gt;&gt;</code> is now waiting for further input. Enter the following command:</p>
<pre><code class="language-text">&gt;&gt;&gt; print (&quot;Hello, World!&quot;)
Hello, World!
</code></pre>
<p>Press Ctrl-D to exit from the Python interpreter and return to the command prompt.</p>
<p>Close the shell session:</p>
<pre><code class="language-text"># exit
</code></pre>
<p>You have just written your first PLCnext Control program!</p>
<h3 id="your-second-program"><a class="header" href="#your-second-program">Your Second Program</a></h3>
<p>You probably don't want to be limited to Python when building applications. Python scripts are quick and easy to run on a PLCnext Control device because the firmware includes a Python interpreter. Other interpreted languages (like Javascript) need their own interpreter. Similarly, Java bytecode and .NET CLI code need their own runtimes. It is beyond the scope of this book to describe how to program a PLCnext Control device in every language. Appendix A includes a list of resources that demonstrate how to use PLCnext Control devices with a number of popular programming languages and frameworks, including contributions from members of the PLCnext Community.</p>
<p>Native applications can be built for a PLCnext Control device using C/C++ or Rust, for example, with the help of the appropriate Software Development Kit (SDK). Next, we will see how to install the SDK for a PLCnext Control device on your host machine, and then write &quot;Hello, World!&quot; programs for that controller in C/C++ and Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installing-a-software-development-kit"><a class="header" href="#installing-a-software-development-kit">Installing a Software Development Kit</a></h2>
<p>You can build native applications for a PLCnext Control device - either from third-party open-source code, or from your own code. To do this, you must install a software development kit (SDK) on the host, corresponding to the firmware that is running on the PLCnext Control device. The SDK contains the build tools and other resources required to create native applications for the target.</p>
<h3 id="plcnext-command-line-interface"><a class="header" href="#plcnext-command-line-interface">PLCnext Command Line Interface</a></h3>
<p>Software development kits for PLCnext Control targets are installed and managed using a command-line interface (CLI), called the <em>PLCnext CLI</em> or <code>plcncli</code>. It is possible to install SDKs on the host without using <code>plcncli</code>, but <code>plcncli</code> provides important features that will be required in later chapters of this book. For this reason, it is highly recommended to install and manage SDKs using <code>plcncli</code>.</p>
<p>To install <code>plcncli</code> on your host:</p>
<ul>
<li>
<p>Download the file <em>PLCnext Technology C++ tool chain for Linux</em> from the Phoenix Contact website. For example, the file <code>PLCnCLI_SDK_2021.6_Linux_AXC_F_2152.tar.gz</code> is for the AXC F 2152 running firmware version 2021.6.</p>
</li>
<li>
<p>Extract the files from the archive.</p>
</li>
<li>
<p>In a terminal window, navigate to the directory where the files were extracted.</p>
</li>
<li>
<p>Optional: See what commands are available </p>
</li>
<li>
<p>Run the script to set up <code>plcncli</code> on the host, specifying the directory where the package should be installed.</p>
<pre><code class="language-text">$ ./PLCnCLI_Setup.sh --target ~/plcncli
</code></pre>
<p>Read the terms and conditions carefully and, if you agree with them, type <code>y</code>.</p>
</li>
<li>
<p>Create a symbolic link to the <code>plcncli</code> executable, as suggested by the installation message.</p>
</li>
<li>
<p>Check that the installation has been successful.</p>
<pre><code class="language-text">$ plcncli
plcncli 21.6.0 (21.6.0.726)
Copyright (c) 2018 PHOENIX CONTACT GmbH &amp; Co. KG
</code></pre>
</li>
</ul>
<h3 id="plcnext-sdk"><a class="header" href="#plcnext-sdk">PLCnext SDK</a></h3>
<ul>
<li>
<p>In a terminal window, navigate to the directory where the files were extracted from the archive.</p>
</li>
<li>
<p>Use plcncli to install the SDK. You are free to specify any destination directory you want, using the <code>-d</code> option.</p>
<pre><code class="language-text">$ plcncli install sdk -p pxc-glibc-x86_64-axcf2152-image-sdk-cortexa9t2hf-neon-axcf2152-toolchain-2021.6.sh -d /opt/pxc/sdk/AXCF2152/2021.6
(todo: response))
</code></pre>
<p>You may need to change the permissions on the SDK installation file to give the current user execute privilege.</p>
</li>
<li>
<p>Check what SDKs and targets have been installed.</p>
<pre><code class="language-text">$ plcncli get sdks
{
   &quot;sdks&quot;: [
      {
         &quot;path&quot;: &quot;/opt/pxc/sdk/AXCF2152/2021.6&quot;
      }
   ]
}
</code></pre>
<pre><code class="language-text">$ plcncli get targets
{
   &quot;targets&quot;: [
      {
         &quot;name&quot;: &quot;AXCF2152&quot;,
         &quot;version&quot;: &quot;21.6.0.46&quot;,
         &quot;longVersion&quot;: &quot;2021.6.0 (21.6.0.46)&quot;,
         &quot;shortVersion&quot;: &quot;21.6.0&quot;,
         &quot;available&quot;: null
      }
   ]
}
</code></pre>
</li>
</ul>
<p>Note that the above responses are in JSON format, which makes it easier to integrate plcncli operations into an automated workflow if required.</p>
<p>If you need to build applications for different PLCnext Control hardware and/or firmware variants, then it is possible to use <code>plcncli</code> to install multiple SDKs on the host. To do this, simply repeat the installation procedure for each additional SDK. There is no need to install <code>plcncli</code> again.</p>
<h3 id="alternative-sdk-installation-methods"><a class="header" href="#alternative-sdk-installation-methods">Alternative SDK installation methods</a></h3>
<p>If you are writing C++ applications in Eclipse or Visual Studio, then it is possible to install PLCnext SDKs through those IDEs. All SDK installation methods are described in the <a href="https://plcnext.help/te/Programming/PLCnext_toolchain/Managing_SDKs.htm">PLCnext Info Center</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-again-world"><a class="header" href="#hello-again-world">Hello Again, World!</a></h2>
<p>Once you have an SDK installed on your host machine, your PLCnext Control device can greet the world in C++ or Rust.</p>
<h3 id="c"><a class="header" href="#c">C++</a></h3>
<p>On the host machine, create a file called <code>main.cpp</code> with the following contents:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>When <a href="https://www.gnu.org/software/automake/manual/html_node/Cross_002dCompilation.html">cross-compiling</a> open-source C/C++ code using the <a href="https://www.gnu.org/software/automake/manual/html_node/GNU-Build-System.html">GNU Build System</a>, it is typical - and often necessary - to define an environment variable called <code>SDKROOT</code>. This variable contains the path where header files, shared libraries, build tools etc. for the target platform can be found. Defining this variable is not necessary for this simple example, but let's do it anyway. In this case, we define <code>SDKROOT</code> as the directory in the SDK that contains the <code>sysroot</code> directory. For example:</p>
<pre><code class="language-text">$ export SDKROOT=/opt/pxc/sdk/AXCF2152/2021.6
</code></pre>
<p>The PLCnext SDK includes a bash script that sets up the build environment, so that standard build commands will result in binaries for the target platform. Execute this bash script using the <code>source</code> command:</p>
<pre><code class="language-text">$ source ${SDKROOT}/environment-setup*
</code></pre>
<p>Now we can compile and link the program using the g++ compiler that comes with the PLCnext SDK:</p>
<pre><code class="language-text">$ $CXX main.cpp -O -o say_hello  # Build with optimisations (-O) to avoid a warning.
</code></pre>
<p>Check that the resulting executable has been built for the correct platform:</p>
<pre><code class="language-text">$ file say_hello
say_hello: ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, BuildID[sha1]=b4a827997b3375494f750fa890c8796ff293d463, for GNU/Linux 3.2.0, with debug_info, not stripped
</code></pre>
<p>Copy the executable to the PLCnext Control device:</p>
<pre><code class="language-text">$ scp say_hello admin@192.168.1.10:~
</code></pre>
<p>Run the program on the PLCnext Control device:</p>
<pre><code class="language-text">$ ssh admin@192.168.1.10
# ./say_hello
Hello World!
</code></pre>
<p>Congratulations! You have just run your first C++ program on a PLCnext Control device.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>The build process for a simple Rust program targeting a PLCnext Control device is described in the <a href="https://github.com/PLCnext/rust-sample-runtime/blob/master/getting-started/Part-01/README.md">first step of the rust-sample-runtime tutorial in Github</a>.</p>
<h3 id="building-on-target"><a class="header" href="#building-on-target">Building on target</a></h3>
<p>The software development process for PLCnext Control devices - cross-compiling on a host, then deploying to a target - will be familiar to those with experience in embedded systems software development, but other programmers often wonder why they cannot build their PLCnext Control applications directly on the target device. The reason is that the resources required to run development and build tools are often orders of magnitude greater than those required to run the final application, and the types of applications for which PLCnext Control is designed cannot justify the cost of these additional resources (e.g. memory and CPU power). For this reason, PLCnext Control should be considered more like an embedded device rather than a full-featured computer.</p>
<h3 id="accessing-plc-io"><a class="header" href="#accessing-plc-io">Accessing PLC I/O</a></h3>
<p>After writing their first program, one of the first questions most PLCnext Control programmers ask is: How can an application read and write inputs and outputs from/to the I/O modules attached to the PLCnext Control device?</p>
<p>Before you learn how to do this, you must learn about the <em>PLCnext runtime</em>. But first, you should know about some basic features of the operating system that runs on every PLCnext Control device.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="operating-system"><a class="header" href="#operating-system">Operating System</a></h2>
<p>The firmware on a PLCnext Control includes standard Linux features that will be familiar to systems and network administrators. These features are described in the <a href="https://www.plcnext.help/te/Operating_System/Operating_system.htm">PLCnext Technology Info Centre</a>.</p>
<p>This chapter describes operating system features that are likely to be useful to developers of PLCnext Control applications. Some of these features are common to all Linux-based operating systems, and some are specific to PLCnext Control devices:</p>
<ul>
<li>Security</li>
<li>Users and Privileges</li>
<li>Firmware, including installing updates</li>
<li>File system</li>
<li>Installing software</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>As is the case with all computer systems, it is ultimately the responsibility of the end user to protect their equipment against all potential threats.</p>
<p>The security tools provided with PLCnext Control firmware are described in the <a href="https://www.plcnext.help/te/Security/Security.htm">PLCnext Technology Info Centre</a>. These tools will be familiar to administrators of Linux devices.</p>
<p>In addition, users should always follow general IT security principles like <a href="https://dam-mdc.phoenixcontact.com/asset/156443151564/0a870ae433c19148b80bd760f3a1c1f2">those published by Phoenix Contact</a> (PDF download).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="users-and-privileges"><a class="header" href="#users-and-privileges">Users and Privileges</a></h2>
<p>Much of the information below also appears in the <a href="https://www.plcnext.help/te/Operating_System/Root_rights.htm">PLCnext Info Center</a>.</p>
<h3 id="admin-user"><a class="header" href="#admin-user">admin user</a></h3>
<p>By default, the <code>admin</code> user is granted the privilege to run a number of commands as a super-user. You can see the complete list of these commands as follows:</p>
<pre><code class="language-text">admin@axcf2152:~$ sudo -l
Password:
User admin may run the following commands on axcf2152:
    (ALL) /usr/bin/passwd
    (ALL) /sbin/ifconfig
    (ALL) /bin/date
    (ALL) /etc/init.d/plcnext
    (ALL) /etc/init.d/openvpn
    (ALL) /etc/init.d/ntpd
    (ALL) /etc/init.d/sshd
    (ALL) /usr/sbin/ipsec
    (ALL) /usr/sbin/swanctl
    (ALL) /etc/init.d/firewall
    (ALL) /usr/sbin/nft
    (ALL) /sbin/ldconfig
    (ALL) /sbin/shutdown
    (ALL) /sbin/reboot
    (ALL) /usr/sbin/tcpdump
    (ALL) /usr/sbin/update-rc.d
    (ALL) /usr/sbin/update-plcnext
    (ALL) /usr/sbin/recover-plcnext
    (ALL) /usr/bin/dpkg
    (ALL) /usr/bin/gdbserver
    (ALL) /usr/bin/gdbserver-plcnext.sh
    (ALL) /usr/bin/gdbserver-preprocess.sh
    (ALL) /usr/bin/gdbserver-prio-request.sh
    (ALL) /usr/bin/gdbserver-prio-set.sh
    (ALL) /usr/bin/gdbserver-start-program-wrapper.sh
    (ALL) /usr/sbin/update-axcf2152
    (ALL) /usr/sbin/recover-axcf2152
    (ALL) /usr/bin/gdbserver-plcnext.sh
    (ALL) /usr/bin/gdbserver-preprocess.sh
    (ALL) /usr/bin/gdbserver-prio-request.sh
    (ALL) /usr/bin/gdbserver-prio-set.sh
    (ALL) /usr/bin/gdbserver-start-program-wrapper.sh
    (ALL) /usr/sbin/sdcard_state.sh
</code></pre>
<p>These sudo privileges are granted using configuration files in the <code>/etc/sudoers.d</code> directory.</p>
<h3 id="extending-admin-privileges"><a class="header" href="#extending-admin-privileges">Extending admin privileges</a></h3>
<p>In some cases it may be required to grant the <code>admin</code> user the privilege to execute more commands than those listed above. This can be done by adding one or more files to the <code>/etc/sudoers.d</code> directory.</p>
<p>In the extreme case, it is possible to grant the admin user the right to execute all commands on the controller, by adding a file to the <code>/etc/sudoers.d</code> directory containing the following line:</p>
<pre><code class="language-text">admin ALL=(ALL) ALL
</code></pre>
<p>Note that it is not recommended to edit or delete any file that is installed with the firmware.</p>
<h3 id="root-user"><a class="header" href="#root-user">root user</a></h3>
<p>In some cases it may be required to switch to the root user. In this case, a root user password must first be set, using the following command:</p>
<pre><code class="language-text">admin@axcf2152:~$ sudo passwd root

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

Password: *Enter admin user password*

Changing password for root
Enter the new password (minimum of 5 characters)
Please use a combination of upper and lower case letters and numbers.
New password: *Enter root user password*
Re-enter new password: *Confirm password*
</code></pre>
<p>You can now switch to the root user using the command <code>su root</code>, or simply <code>su</code>.</p>
<h3 id="creating-an-ssh-session-as-root"><a class="header" href="#creating-an-ssh-session-as-root">Creating an ssh session as root</a></h3>
<p>In some cases, it may be required to connect directly to the controller as <code>root</code>, using <code>ssh</code> or its associated utilities (<code>scp</code>, <code>sftp</code>, etc).</p>
<p>In order to open an ssh session on the controller as <code>root</code>, the ssh daemon must be configured to accept logins from that user. To do this, log in to the controller as <code>admin</code>, switch to the <code>root</code> user using the <code>su</code> command, and edit the <code>/etc/ssh/sshd_config</code> file using your favourite editor.</p>
<blockquote>
<p>The controller includes <code>vi</code> (vim) and <code>nano</code> text editors.
There are many online resources available if you need to learn how to use one these editors.</p>
</blockquote>
<p>In the <code>sshd_config</code> file, remove the comment symbol <code>#</code> from this line:</p>
<pre><code class="language-text">#PermitRootLogin yes
</code></pre>
<p>Save the file, exit from the editor, and restart the ssh daemon:</p>
<pre><code class="language-text">root@axcf2152:~# /etc/init.d/sshd restart
</code></pre>
<h3 id="logging-in-without-a-password"><a class="header" href="#logging-in-without-a-password">Logging in without a password</a></h3>
<p>For activities that require frequent login to a PLCnext Control device, e.g. during application development and testing, it can become tedious to repeatedly enter the same password. It is possible to use key-based SSH authentication to eliminate this chore, without compromising security.</p>
<p>The following article from a Phoenix Contact technical support site describes how to implement this standard Linux feature for the <code>admin</code> user on a PLCnext Control device:</p>
<p><a href="https://pxc1.esc-eu-central-1.empolisservices.com/gatekeeper/guesttoken/45?app=/service-express/portal/cb?redirect=https://pxc1.esc-eu-central-1.empolisservices.com/service-express/portal/object/esc/en-so-30b315c3-3e44-4292-97d4-6883672cd34c">How to set up key-based SSH authentication to a PLCnext Control device.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setting-the-time"><a class="header" href="#setting-the-time">Setting the Time</a></h2>
<p>Like with other Linux distributions, it is possible to set the date and time on a PLCnext Control device using the <code>date</code> command.</p>
<p>By default, each PLCnext Control device is configured to use Coordinated Universal Time (UTC). You should set the date and time on your device to the correct UTC time. This will - among other things - avoid problems with security certificates, which often require the time on the device to be more or less correct.</p>
<h3 id="network-time-protocol"><a class="header" href="#network-time-protocol">Network Time Protocol</a></h3>
<p>If the device has access to a Network Time Protocol (NTP) server, either locally or on the internet, then it is possible to use that NTP server to maintain the correct time on the PLCnext Control device. Like with other Linux distributions, this can be achieved by editing the file <code>/etc/ntp.conf</code> on the device.</p>
<p>Information on how to set the time on a PLCnext Control device using various methods is available in the <a href="https://www.plcnext.help/te/Operating_System/System_time.htm">PLCnext Info Center</a>.</p>
<h3 id="setting-the-time-zone"><a class="header" href="#setting-the-time-zone">Setting the Time Zone</a></h3>
<p>For applications that use local time rather than universal time, you may want to set the time zone on your PLCnext Control device using the procedure in the following article:</p>
<p><a href="https://pxc1.esc-eu-central-1.empolisservices.com/gatekeeper/guesttoken/45?app=/service-express/portal/cb?redirect=https://pxc1.esc-eu-central-1.empolisservices.com/service-express/portal/object/esc/en-so-deb95804-1aba-4247-8d77-da744c190b90">How to set the time zone on a PLCnext Control device.</a></p>
<p>The release notes for firmware version 2021.9 state that &quot;Setting local time zones is not fully supported&quot;. The procedure in the above article involves editing a system configuration file, which may cause problems during future firmware upgrades.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="firmware"><a class="header" href="#firmware">Firmware</a></h2>
<p>The PLCnext Control firmware includes both the Linux kernel and factory-installed software from Phoenix Contact. A PLCnext Control device can be updated with a different firmware version at any time, if required. In general, newer firmware will only add non-breaking features and bug-fixes to older versions, so applications that are designed for a specific firmware version should (generally) be able to run on newer firmware versions without modification.</p>
<h3 id="firmware-release-schedule"><a class="header" href="#firmware-release-schedule">Firmware Release Schedule</a></h3>
<p>PLCnext Control firmware is generally released four times a year; the first is a Long Term Support (LTS) version, and the other three are &quot;feature&quot; releases for those who want the very latest features as early as possible. The <a href="https://plcnext.help/te/Product_range/Releases.htm">firmware release history and  future release schedule</a> is shown in the PLCnext Info Center.</p>
<p>There is also some information on <a href="https://www.plcnext.help/te/Features_and_roadmaps/Roadmaps.htm">upcoming firmware features</a> in the PLCnext Info Center.</p>
<h3 id="checking-the-firmware-version"><a class="header" href="#checking-the-firmware-version">Checking the Firmware Version</a></h3>
<p>It is important to know the firmware version that is running on the device for a number of reasons:</p>
<ul>
<li>
<p>When building native applications, you must use a software development kit (SDK) that is compatible with the firmware version that will run the application.</p>
</li>
<li>
<p>When installing third-party applications that have been built specifically for PLCnext Control devices, you may need to select a version that is compatible with the firmware running on your device.</p>
</li>
<li>
<p>When looking for assistance in the <a href="https://www.plcnext-community.net">PLCnext Community</a>, it will often help to know what firmware version is currently running on the device.</p>
</li>
</ul>
<p>You can check the version of firmware currently running on the device by listing the contents of the <code>arpversion</code> file in the <code>/etc/plcnext/</code> directory.</p>
<pre><code class="language-text"># cat /etc/plcnext/arpversion
Arpversion: 21.6.0.46
GIT Commit Hash: 8f3c6754f20bab7c5cd88aa4de07a797c3153516
Build Job: &quot;jenkins-PLCnext-Yocto_Targets-Yocto_AXCF2152-release%2F21.6.x-46&quot;
</code></pre>
<p>The firmware version is shown in the <em>Arpversion</em> field - in this case, 21.6.0.46.</p>
<h3 id="upgrading-the-firmware"><a class="header" href="#upgrading-the-firmware">Upgrading the Firmware</a></h3>
<p>New versions of PLCnext Control firmware are released regularly. If the firmware on your device is not the latest, you may want to upgrade it to get the benefit of new features and bug fixes. The firmware on a PLCnext Control device can be upgraded by following these steps:</p>
<ul>
<li>
<p>Download the firmware update file (ZIP archive) for your controller from the Phoenix Contact website.</p>
</li>
<li>
<p>Extract the <code>.raucb</code> file from the archive.</p>
<p>Now you can guess (correctly) that PLCnext Control devices use <a href="https://rauc.io/">RAUC</a> for firmware updates.</p>
</li>
<li>
<p>Copy the <code>.raucb</code> file to the device:</p>
<pre><code class="language-text">$ scp axcf2152-bundle-base-axcf2152.raucb admin@192.168.1.10:~
</code></pre>
</li>
<li>
<p>Open a shell session:</p>
<pre><code class="language-text">$ ssh admin@192.168.1.10
</code></pre>
</li>
<li>
<p>Update the firmware:</p>
<pre><code class="language-text"># sudo /etc/init.d/plcnext stop
Password:
Stopping service plcnext
plcnext stopped
#
# admin@axcf2152:~$ rauc install axcf2152-2022.0.0.13-LTS-beta.raucb
installing
0% Installing
0% Determining slot states
20% Determining slot states done.
20% Checking bundle
20% Verifying signature
40% Verifying signature done.
40% Checking bundle done.
40% Checking manifest contents
60% Checking manifest contents done.
60% Determining target install group
80% Determining target install group done.
80% Updating slots
80% Checking slot rootfs.0
90% Checking slot rootfs.0 done.
90% Copying image to rootfs.0
100% Copying image to rootfs.0 done.
100% Updating slots done.
100% Installing done.
Installing `/opt/plcnext/axcf2152-2022.0.0.13-LTS-beta.raucb` succeeded
#
# sudo reboot
</code></pre>
</li>
</ul>
<p>After the device restarts, open a new shell session and check the firmware version.</p>
<h3 id="but-theres-more"><a class="header" href="#but-theres-more">But There's More!</a></h3>
<p>There are actually three firmware copies lurking on a PLCnext Control device, and all three may be different versions. The above procedure only replaces one of these three firmware installations. You will learn more about this in the next section.</p>
<h3 id="other-ways-to-upgrade-firmware"><a class="header" href="#other-ways-to-upgrade-firmware">Other Ways to Upgrade Firmware</a></h3>
<p>There are currently many other ways to upgrade the firmware on the controller, including:</p>
<ul>
<li>
<p>Using the <code>update-plcnext</code> script, as described in the <a href="https://www.plcnext.help/te/Operating_System/Operating_system.htm">Firmware update</a> section of the PLCnext Info Center.</p>
</li>
<li>
<p>Through <a href="https://www.plcnext.help/te/WBM/Administration_Firmware_Update.htm">web-based management</a> (WBM).</p>
</li>
<li>
<p>Using the Device Management service on the <a href="https://proficloud.io/">Proficloud</a> web site.</p>
</li>
<li>
<p>Using an OPC UA client (not currently documented).</p>
</li>
<li>
<p>Using <a href="https://www.eclipse.org/hawkbit/">Eclipse hawkBit™</a> with the <a href="https://www.plcnextstore.com/permalinks/apps/latest/60002172000381">hawkBit™ client app</a> from the PLCnext Store.</p>
</li>
<li>
<p>Using the <code>StartFirmwareUpdate</code> method on the <a href="https://www.plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_device_interface_services.htm#IDeviceControlService">Device Control</a> PLCnext runtime service.</p>
</li>
</ul>
<p>All the methods listed above require that the PLCnext runtime is running. If this is the case, then firmware upgrades should be performed using one of these methods rather than using the <code>rauc</code> command.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disk-partitions"><a class="header" href="#disk-partitions">Disk Partitions</a></h2>
<p>The internal storage in a PLCnext Control device is divided into a number of partitions, including:</p>
<ul>
<li>Boot partition.</li>
<li>Device data partition.</li>
<li>3 x Root File System (RFS) partitions.</li>
<li>User data partition.</li>
</ul>
<h3 id="device-data"><a class="header" href="#device-data">Device Data</a></h3>
<p>Device data includes data that is specific to an individual device, e.g. security certificates and other data that is tied to the specific trusted platform module (TPM) chip in the device. If this data is damaged, the device may become inoperable and unrecoverable.</p>
<h3 id="root-file-systems"><a class="header" href="#root-file-systems">Root File Systems</a></h3>
<p>There are always three root file systems on a PLCnext Control device:</p>
<ol>
<li>
<p>Active file system.</p>
</li>
<li>
<p>Inactive file system. This is a &quot;standby&quot; file system that is used in case the device cannot boot using the active file system.</p>
</li>
<li>
<p>Recovery file system. Used to replace the other two file systems during a type 2 reset (described in the next section).</p>
</li>
</ol>
<p>Each file system is located on a different partition on the device's internal storage.</p>
<p>When a device is shipped from the factory, all three root file systems are the same version - usually from the latest LTS firmware version that was available when the device was manufactured.</p>
<p>The firmware update procedure described in the previous section actually proceeds as follows:</p>
<ul>
<li>The new root file system is extracted from the firmware image and installed on the inactive boot partition.</li>
<li>When the device restarts next, the active and inactive partitions are swapped, so the device uses the file system from the newly installed firmware.</li>
</ul>
<p>The status of the root file systems can be seen using the following command:</p>
<pre><code class="language-text"># rauc status --detailed
=== System Info ===
Compatible:  axcf2152_v1
Variant:    
Booted from: rootfs.0 (A)

=== Bootloader ===
Activated: rootfs.0 (A)

=== Slot States ===
o [rootfs.1] (/dev/mmcblk0p3, ext4, inactive)
bootname: B
boot status: good
      slot status:
          bundle:
              compatible=axcf2152_v1
              version=2021.9
              description=Update container for axcf2152
              build=20210930133602
          checksum:
              sha256=12c4bc62a65e6abd4479d1d2b930cba2bde3fc5412f6fc94b3d29761e33d2661
              size=575712256
          installed:
              timestamp=2020-03-11T13:35:02Z
              count=1
          activated:
              timestamp=2020-03-11T13:35:02Z
              count=1
          status=ok

x [rootfs.0] (/dev/mmcblk0p2, ext4, booted)
bootname: A
mounted: /media/rfs/ro
boot status: good
      slot status:
          bundle:
              compatible=axcf2152_v1
              version=2022.0
              description=Update container for axcf2152
              build=20211029212448
          checksum:
              sha256=0a27a82bb7f4c02449c3c78dadb1a3d300de9c861a40f27ea55db7c3af013558
              size=598693888
          installed:
              timestamp=2021-11-08T08:59:15Z
              count=1
          activated:
              timestamp=2021-11-08T08:59:16Z
              count=1
          status=ok
</code></pre>
<p>This shows that the active root file system contains firmware version 2022.0, and that the inactive root file system contains firmware version 2021.9.</p>
<p>The PLCnext Info  Center gives this explanation:</p>
<blockquote>
<p>If the boot process failed several consecutive times, the inactive and the active boot partition will change their roles, too. This behavior has been implemented to keep the PLCnext Control device accessible even if the firmware update fails. The behavior can also occur when the boot process is interrupted e.g. by power loss. In this case you will observe that the controller boots with its previously installed firmware version.
<strong>To prevent such unintended firmware downgrades, Phoenix Contact recommends that after a successful firmware update, the same firmware should be installed once again.</strong> This way both the active and the inactive boot partition contain the same firmware version.</p>
</blockquote>
<h3 id="user-data"><a class="header" href="#user-data">User Data</a></h3>
<p>The user data partition includes:</p>
<ul>
<li>All user-configurable files that are installed with the firmware.</li>
<li>Any files added to the device by the user.</li>
</ul>
<p>If a removeable SD card is inserted into the PLCnext Control device, then the user data partition on the internal storage device will not be used, and user data will instead be stored on the removeable SD card. External SD cards are currently available in sizes up to 32GB, which provides a much greater storage capacity than the user data partition in internal memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="file-system"><a class="header" href="#file-system">File System</a></h2>
<p>Files in a PLCnext Control are arranged in an <a href="https://www.datalight.com/blog/2016/01/27/explaining-overlayfs-%E2%80%93-what-it-does-and-how-it-works">overlay file system</a>.</p>
<p>The firmware is installed in the lower (read only) directory. All files created by users, and any changes to files in the lower directory, are stored in the upper (read/write) directory.</p>
<h3 id="storage-media"><a class="header" href="#storage-media">Storage Media</a></h3>
<p>Each PLCnext Control device includes internal, non-volatile, solid-state memory. The PLC is also supplied with an empty SD card slot.</p>
<blockquote>
<p>The firmware will only recognise SD cards specifically designed for PLCnext Control devices.</p>
</blockquote>
<p>The firmware file system, mounted as the read-only lower directory, is <em>always</em> stored in internal memory. This includes all three of firmware images described in the previous section. Information on the firmware file system is available in the <a href="https://www.plcnext.help/te/Operating_System/Firmware_directories.htm">PLCnext Technology Info Centre</a>.</p>
<p>If the PLC boots without an SD card present, the internal memory is used as the primary storage media for the user file system, since it is the only memory available. If the PLC boots with an SD card present, the SD card is used as the primary storage media for the user file system.</p>
<blockquote>
<p>Please note the SD card handling guidelines in the user manual for your PLCnext Control device.</p>
</blockquote>
<p>In relation to the upper directory, the behaviour of the system when booting depends on the presence or absence of an external SD card, and the presence or absence of a user file system on the primary storage media:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"></th><th style="text-align: left">Primary<br/>media</th><th style="text-align: left">User file system absent on primary media</th><th style="text-align: left">User file system present on primary media</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>SD card absent</strong></td><td style="text-align: left">Internal<br/>memory</td><td style="text-align: left">User file system is created in internal memory<br/>and mounted as upper directory.</td><td style="text-align: left">Existing file system in internal memory<br/>is mounted as upper directory.</td></tr>
<tr><td style="text-align: left"><strong>SD card present</strong></td><td style="text-align: left">SD card</td><td style="text-align: left">User file system is moved from internal memory to<br/>the SD card and mounted as upper directory.</td><td style="text-align: left">Existing user file system on SD card<br/>is mounted as upper directory.<br/><em>Any internal user file system is deleted.</em></td></tr>
</tbody></table>
</div>
<blockquote>
<p>Note that in the case shown in the lower right corner of the above table, data loss may occur.</p>
</blockquote>
<p>More information on this topic is available in the <a href="https://www.plcnext.help/te/WBM/Security_SD_Card_settings.htm">PLCnext Technology Info Centre</a>.</p>
<h3 id="deleting-and-restoring-file-systems"><a class="header" href="#deleting-and-restoring-file-systems">Deleting and Restoring File Systems</a></h3>
<p>The following procedures will affect the complete firmware and/or user file system in a PLCnext Control device:</p>
<h4 id="firmware-update"><a class="header" href="#firmware-update">Firmware Update</a></h4>
<p>During a firmware update, the contents of the firmware file system are replaced with new firmware files. The user file system remains unaffected, and so (for example) the IP address of the PLC will be retained, passwords will be unaffected, and user-installed files will not be deleted.</p>
<blockquote>
<p>Note: Since manual changes to firmware files are stored in the upper directory, any firmware files that were changed manually before a firmware update will remain in the upper directory and will continue to mask the corresponding file in the new firmware file system. This may adversely affect the operation of the PLC after a firmware update. It is therefore recommended that firmware files are never manually changed or deleted.</p>
</blockquote>
<h4 id="type-1-reset"><a class="header" href="#type-1-reset">Type 1 Reset</a></h4>
<p>A type 1 reset deletes the entire contents of the user file system on the primary storage device. The contents of the firmware file system remain unaffected.</p>
<p>To perform a type 1 reset, open a secure shell session on the PLC, and issue the following command:</p>
<pre><code class="language-text"># sudo recover-plcnext 1
</code></pre>
<h4 id="type-2-reset"><a class="header" href="#type-2-reset">Type 2 Reset</a></h4>
<p>A type 2 reset:</p>
<ul>
<li>
<p>Deletes the entire contents of the user file system on the primary storage device, just like a type 1 reset.</p>
</li>
<li>
<p>Replaces the firmware file system with a factory-default firmware version.</p>
</li>
</ul>
<p>Note that a type 2 reset may not restore the device to its factory default state, since some user files may have been stored outside the upper directory. The most common way this happens is when using an <a href="https://opencontainers.org/">OCI</a> engine like Docker, Balena or Podman, which store files outside the overlay file system by default.</p>
<p>To perform a type 2 reset, open a secure shell session on the PLC, and issue the following command:</p>
<pre><code class="language-text"># sudo recover-plcnext 2
</code></pre>
<blockquote>
<p>Warning: After either a type 1 or a type 2 reset, all user data will be deleted and the PLC's IP address and <code>admin</code> password will be restored to factory defaults.</p>
</blockquote>
<p>On some devices, it is also possible to perform a type 1 or a type 2 reset using a button on the front of the PLCnext Control. See the user manual for details.</p>
<h3 id="backups"><a class="header" href="#backups">Backups</a></h3>
<p>It is highly recommended to take regular backups of the user file system.</p>
<p>Phoenix Contact does not currently provide a standard backup/restore procedure for user data, however you can prepare your own procedure using the examples on the <a href="https://github.com/PLCnext/UtilityScripts#backups">PLCnext Github page</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installing-software"><a class="header" href="#installing-software">Installing Software</a></h2>
<p>Now that you are familiar with some of the features of the Linux operating system on PLCnext Control devices, lets see how you can extend the functionality of the controller by installing third-party software.</p>
<p>Those familiar with other Linux distributions will know about package managers like <a href="https://en.wikipedia.org/wiki/APT_(software)">apt</a>. Unfortunately neither <code>apt</code> nor any eqiuvalent package manager is available on PLCnext Control devices by default. PLCnext Control firmware does include <a href="https://en.wikipedia.org/wiki/Dpkg">dpkg</a>, but it does not include a database of installed software, so <code>dpkg</code> cannot know if any dependencies listed in a <code>.deb</code> package have already been installed with the firmware.</p>
<p>Various users of PLCnext Control devices have documented their own procedure for adding a package mananger to PLCnext Control devices, including <code>apt</code>, <code>ipkg</code> and <code>guix</code>. None of these are entirely problem-free, so if you decide to try this yourself- proceed with caution.</p>
<h3 id="the-plcnext-store"><a class="header" href="#the-plcnext-store">The PLCnext Store</a></h3>
<p>The recommended way to add packages to a PLCnext Control device is through the <a href="https://www.plcnextstore.com">PLCnext Store</a>. In order to install and use a package from the PLCnext Store:</p>
<ul>
<li>
<p>The package you need must be available in the PLCnext Store.</p>
</li>
<li>
<p>The package must be installed and started from a web page, either remotely (at <a href="https://www.plcnextstore.com">plcnextstore.com</a>) or on the controller's local <a href="https://www.plcnext.help/te/WBM/Administration_PLCnext_Apps.htm">web-based management</a> page. Package installation from the PLCnext Store cannot currently be automated.</p>
</li>
<li>
<p>In most cases, in order to use a package from the PLCnext Store, the PLCnext Runtime must be running on your PLCnext Control device at all times.</p>
</li>
</ul>
<p>To learn more about the PLCnext Store, visit the <a href="https://store.plcnext.help/">PLCnext Store Info Center</a>.</p>
<h3 id="oci-containers"><a class="header" href="#oci-containers">OCI Containers</a></h3>
<p>Containerised design has become popular in IT applications. <a href="https://opencontainers.org/">OCI</a> containers can also be run on PLCnext Control devices, using one of the following popular container engines:</p>
<ul>
<li><a href="https://podman.io/">Podman</a>. Included with PLCnext Control firmware from version 2021.9</li>
<li><a href="https://www.balena.io/engine/">Balena Engine</a>.</li>
<li><a href="https://www.docker.com/products/container-runtime">Docker Engine</a>.</li>
</ul>
<p>Phoenix Contact has published a <a href="https://github.com/PLCnext/Docker_GettingStarted">Getting Started guide</a> for installing Balena and Docker on PLCnext Control devices.</p>
<h3 id="build-it-yourself"><a class="header" href="#build-it-yourself">Build It Yourself</a></h3>
<ul>
<li>
<p>Directly install a pre-built binary, if available. This must be built for a compatible architecture (e.g. armv7 32 bit).</p>
</li>
<li>
<p>Cross-compile an open-source project using a PLCnext Control SDK.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plcnext-runtime"><a class="header" href="#plcnext-runtime">PLCnext Runtime</a></h1>
<p>PLCnext Control firmware was introduced briefly in the previous chapter. PLCnext Control firmware features can be broadly categorised as either:</p>
<ol>
<li>Features commonly available on general-purpose Linux distributions, or</li>
<li>Features developed by Phoenix Contact, that are not available on other Linux distributions.</li>
</ol>
<p>The second group of features includes:</p>
<ul>
<li>commands like <code>update-plcnext</code> and <code>recover-plcnext</code> that you saw previously, and</li>
<li>software components that are started and controlled by the <em>PLCnext runtime</em>.</li>
</ul>
<p>This chapter will look at:</p>
<ul>
<li>Controlling the PLCnext runtime</li>
<li>PLCnext components</li>
<li>Component instances</li>
<li>Disabling features of the PLCnext runtime</li>
</ul>
<blockquote>
<p>You will see the acronym <em>Arp</em> used extensively throughout this chapter. <em>Arp</em> is short for <em>Automation Runtime Platform</em>, and is another name for the PLCnext runtime.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="controlling-the-plcnext-runtime"><a class="header" href="#controlling-the-plcnext-runtime">Controlling the PLCnext Runtime</a></h2>
<p>When the device boots, it automatically runs the script in the file <code>/etc/init.d/plcnext</code>. This starts the <em>PLCnext runtime</em>.</p>
<p>We can stop the PLCnext runtime any time, using the same script:</p>
<pre><code class="language-text"># sudo /etc/init.d/plcnext stop
Stopping service plcnext
plcnext stopped
</code></pre>
<p>Start the PLCnext runtime, and watch entries being added to the default log file:</p>
<pre><code class="language-text"># sudo /etc/init.d/plcnext start &amp;&amp; tail -f -n 0 /opt/plcnext/logs/Output.log
Starting service plcnext
Set plcnext exports
plcnext started (bus system is axioline)
12.08.21 19:42:14.764 Arp.System.Acf.Internal.ApplicationBase     INFO  - ArpVersion: 2021.6.0 (21.6.0.46)
  :
</code></pre>
<p>You can see lots of activity in the <code>Output.log</code> file when the PLCnext Runtime starts up. The <code>Output.log</code> file is an important source of information - for example, if your PLCnext Control device ever behaves unexpectedly, the <code>Output.log</code> file will often help you to identify the problem.</p>
<p>But what does the PLCnext Runtime do? Basically, the PLCnext runtime turns an otherwise ordinary device into a PLC, and at the same time turns that device into much more than an ordinary PLC.</p>
<p>You have already used one feature of the PLCnext Runtime, when you set the IP address using <code>netnames</code>. Netnames is used to manage Profinet devices, and the PLCnext Runtime starts a component that makes the controller behave like a Profinet device. See what happens when we try to use <code>netnames</code> when the PLCnext Runtime is stopped:</p>
<pre><code class="language-text"># sudo /etc/init.d/plcnext stop
</code></pre>
<p>On the host machine:</p>
<pre><code class="language-text">$ sudo ./netnames -i eth0 -c identify
(no result)
</code></pre>
<p>We can still ping the PLC:</p>
<pre><code class="language-text">$ ping 192.168.1.10
</code></pre>
<p>... because ICMP messages are handled by the Linux operating system, not by the PLCnext runtime. This is also why we can maintain a remote shell session on the PLC, regardless of whether the PLCnext runtime is running or stopped.</p>
<p>Start the PLCnext Runtime again:</p>
<pre><code class="language-text"># sudo /etc/init.d/plcnext start
</code></pre>
<p>... and <code>netnames</code> will again be able to discover the PLC. You may need to wait for up to a minute for the PLCnext runtime to finish starting before <code>netnames</code> will see it.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="diagnosing-problems"><a class="header" href="#diagnosing-problems">Diagnosing problems</a></h2>
<ul>
<li>
<p>Output.log file</p>
<ul>
<li>different log levels</li>
</ul>
</li>
<li>
<p>OPC UA logging</p>
</li>
<li>
<p>Notification Logger (WBM)</p>
</li>
<li>
<p>syslog</p>
</li>
<li>
<p>LTTng</p>
</li>
</ul>
<p>Some hints: https://github.com/savushkin-r-d/PLCnext-howto/tree/master/HowTo%20logging</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="plcnext-runtime-components"><a class="header" href="#plcnext-runtime-components">PLCnext Runtime Components</a></h2>
<p>Factory-installed software components that make up the PLCnext runtime include:</p>
<ul>
<li>Hardware components</li>
<li>I/O and Fieldbus components</li>
<li>System components</li>
<li>PLC components</li>
<li>Service components</li>
</ul>
<p>An overview of these component categories is given in the <a href="https://www.plcnext.help/te/PLCnext_Runtime/Core_component.htm">PLCnext Technology Info Center</a>. The categories are somewhat arbitrary, but during startup all the components in one category are generally started before any components in the next category, and vice-versa during shutdown.</p>
<p>Components are defined in C++ shared object libraries, which are located in the <code>/usr/lib</code> directory on the PLCnext Control device. The tables below list these shared object libraries, the components they define, and links to more information on the function that each component implements.</p>
<h3 id="hardware-components"><a class="header" href="#hardware-components">Hardware Components</a></h3>
<p>These components provide access to device hardware. They typically wrap Linux device drivers, making these devices available to other PLCnext runtime components via internal RSC services.</p>
<ul>
<li>Library filename prefix: <code>libArp.Hardware.</code></li>
<li>Component namespace: <code>Arp::Hardware</code></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Library filename</th><th style="text-align: left">Component type name</th><th style="text-align: left">Service description</th></tr></thead><tbody>
<tr><td style="text-align: left">IdentificationData.so</td><td style="text-align: left">IdentificationData::IdentificationDataComponent</td><td style="text-align: left">Device ID data</td></tr>
<tr><td style="text-align: left">FanControl.so</td><td style="text-align: left">FanControl::FanControlComponent</td><td style="text-align: left">Fan control operations</td></tr>
<tr><td style="text-align: left">Fpga.so</td><td style="text-align: left">Fpga::FpgaComponent</td><td style="text-align: left">FPGA information</td></tr>
<tr><td style="text-align: left">OsControl.so</td><td style="text-align: left">OsControl::OsControlComponent</td><td style="text-align: left">Operating system operations</td></tr>
<tr><td style="text-align: left">RealTimeClock.so</td><td style="text-align: left">RealTimeClock::RealTimeClockComponent</td><td style="text-align: left">Real time clock operations</td></tr>
<tr><td style="text-align: left">ResourceMonitor.so</td><td style="text-align: left">ResourceMonitor::ResourceMonitorComponent</td><td style="text-align: left">CPU, memory and partition monitoring</td></tr>
<tr><td style="text-align: left">DeviceHmi.so</td><td style="text-align: left">DeviceHmi::DeviceHmiComponent</td><td style="text-align: left">Device LEDs, buttons and switches</td></tr>
<tr><td style="text-align: left">Sensors.so</td><td style="text-align: left">Sensors::SensorsComponent</td><td style="text-align: left">Device temperature, humidity and power monitoring</td></tr>
<tr><td style="text-align: left">Nim.so</td><td style="text-align: left">Nim::NimComponent<br/>Nim::NetloadLimiterComponent</td><td style="text-align: left">Ethernet information, IP configuration and IP status<br/><a href="https://www.plcnext.help/te/PLCnext_Runtime/NetLoadLimiter.htm" title="PLCnext Info Center">Network load limiter</a> (public)</td></tr>
<tr><td style="text-align: left">ExternalSDCard.so</td><td style="text-align: left">ExternalSDCard::ExternalSDCardComponent</td><td style="text-align: left">Information on the external SD card license, status and settings</td></tr>
<tr><td style="text-align: left">ExternalPci.so</td><td style="text-align: left">ExternalPci::ExternalPciComponent</td><td style="text-align: left">External PCI state information</td></tr>
</tbody></table>
</div>
<h3 id="device-components"><a class="header" href="#device-components">Device Components</a></h3>
<p>These components provide device-specific abstractions for some low-level hardware services.</p>
<ul>
<li>Library filename prefix: <code>libArp.Device.</code></li>
<li>Component namespace: <code>Arp::Device</code></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Library filename</th><th style="text-align: left">Component type name</th><th style="text-align: left">Service description</th></tr></thead><tbody>
<tr><td style="text-align: left">HmiLed.so</td><td style="text-align: left">HmiLed::HmiLedComponent</td><td style="text-align: left">LED management (internal)</td></tr>
<tr><td style="text-align: left">Interface.so</td><td style="text-align: left">Interface::DiComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_device_interface_services.htm#IDeviceControlService" title="PLCnext Info Center">Device control</a> (public)<br/><a href="https://www.plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_device_interface_services.htm#IDeviceInfoService" title="PLCnext Info Center">Device information</a> (public)<br/><a href="https://www.plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_device_interface_services.htm#IDeviceSettingsService" title="PLCnext Info Center">Device settings</a> (public)<br/><a href="https://www.plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_device_interface_services.htm#IDeviceStatusService" title="PLCnext Info Center">Device status</a> (public)</td></tr>
</tbody></table>
</div>
<h3 id="io-components"><a class="header" href="#io-components">I/O Components</a></h3>
<p>These components provide access to physical I/O modules through a variety of standard industrial networks.</p>
<ul>
<li>Library filename prefix: <code>libArp.Io.</code></li>
<li>Component namespace: <code>Arp::Io</code></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Library filename</th><th style="text-align: left">Component type name</th><th style="text-align: left">Function</th><th style="text-align: left">Condition</th></tr></thead><tbody>
<tr><td style="text-align: left">Axioline.so</td><td style="text-align: left">Axioline::AxiolineComponent</td><td style="text-align: left">Axioline master<sup>1</sup></td><td style="text-align: left">ARP_COMPONENT_AXIOLINE</td></tr>
<tr><td style="text-align: left">Interbus.so</td><td style="text-align: left">Interbus::InterbusComponent</td><td style="text-align: left">Interbus master<sup>1</sup></td><td style="text-align: left">ARP_COMPONENT_INTERBUS</td></tr>
<tr><td style="text-align: left">EthernetIP.so</td><td style="text-align: left">EthernetIP::EthernetIPComponent</td><td style="text-align: left">Ethernet/IP device<sup>1</sup></td><td style="text-align: left">ARP_COMPONENT_ETHERNETIP</td></tr>
<tr><td style="text-align: left">ProfinetStack.so</td><td style="text-align: left">ProfinetStack::System::SystemComponent<br/>ProfinetStack::Controller::ControllerComponent<br/>ProfinetStack::Device::DeviceComponent</td><td style="text-align: left">Profinet system<br/>Profinet controller<br/>Profinet device</td><td style="text-align: left">ARP_COMPONENT_PROFINET or ARP_COMPONENT_PNC or ARP_COMPONENT_PND</td></tr>
</tbody></table>
</div>
<p><sup>1</sup> Only available on AXC devices.</p>
<h3 id="system-components"><a class="header" href="#system-components">System Components</a></h3>
<p>These components implement low-level PLCnext runtime features. They may provide an API, but are not generally designed to be configurable by end users.</p>
<ul>
<li>Library filename prefix: <code>libArp.System.</code></li>
<li>Component namespace: <code>Arp::System</code></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Library filename</th><th style="text-align: left">Component type name</th><th style="text-align: left">Function</th></tr></thead><tbody>
<tr><td style="text-align: left">Commons.Services.so</td><td style="text-align: left">Commons::Services::Component</td><td style="text-align: left"><a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1System_1_1Commons_1_1Services_1_1Io_1_1IFileSystemInfoService.html" title="API description">File system info</a> (public)<br/><a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1System_1_1Commons_1_1Services_1_1Io_1_1IDirectoryService.html" title="API description">Directory service</a> (public)<br/><a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1System_1_1Commons_1_1Services_1_1Io_1_1IFileService.html" title="API description">File service</a> (public)<br/><a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1System_1_1Commons_1_1Services_1_1Security_1_1IDeviceIdentityValidatorService.html" title="API description">Device ID validator</a> (public)<br/>Trust store management (internal)<br/>Identity store management (internal)</td></tr>
<tr><td style="text-align: left">Security.Services.so</td><td style="text-align: left">Security::Services::Component</td><td style="text-align: left">System security</td></tr>
<tr><td style="text-align: left">Watchdog.so</td><td style="text-align: left">Watchdog::SystemWatchdogComponent</td><td style="text-align: left">System watchdog configuration and monitoring</td></tr>
<tr><td style="text-align: left">RscGateway.so</td><td style="text-align: left">RscGateway::RscGatewayComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_Remote_Service_Calls.htm" title="PLCnext Info Center">Remote service call gateway</a></td></tr>
<tr><td style="text-align: left">Um.so</td><td style="text-align: left">Um::UmComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/WBM/Security_User_authentication.htm" title="PLCnext Info Center">User manager</a></td></tr>
</tbody></table>
</div>
<h3 id="plc-components"><a class="header" href="#plc-components">PLC Components</a></h3>
<p>These components implement features you would expect to find on PLCs.</p>
<p>Library filename prefix: <code>libArp.Plc.</code>
Component namespace: <code>Arp::Plc</code></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Library filename</th><th style="text-align: left">Component type name</th><th style="text-align: left">Function</th></tr></thead><tbody>
<tr><td style="text-align: left">Domain.so</td><td style="text-align: left">Domain::PlcDomainProxyComponent<br/>Domain::PlcManagerComponent<br/>Domain::PlcDomainComponent</td><td style="text-align: left">Related to I/O<br/>?<br/>?</td></tr>
<tr><td style="text-align: left">Meta.so</td><td style="text-align: left">Meta::MetaDomainComponent<br/>Meta::MetaComponent<br/>Meta::MetaControllerComponent</td><td style="text-align: left">GDS traverser (public)<br/>GDS browser (internal)</td></tr>
<tr><td style="text-align: left">Eclr.so</td><td style="text-align: left">Eclr::EclrComponent<br/>Eclr::EclrServicesComponent<br/>Eclr::ArpDomainComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/Programming/Csharp/eCLR_Programming_System.htm" title="PLCnext Info Center">Embedded Common Language Runtime</a></td></tr>
<tr><td style="text-align: left">Plm.so</td><td style="text-align: left">Plm::PlmComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/Programming/Cplusplus/PLM_Program_Library_Manager.htm" title="PLCnext Info Center">Manages real-time C++ programs</a></td></tr>
<tr><td style="text-align: left">Esm.so</td><td style="text-align: left">Esm::EsmComponent<br/>Esm::EsmControllerComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/PLCnext_Runtime/ESM.htm" title="PLCnext Info Center">Execution and Synchronisation Manager</a></td></tr>
<tr><td style="text-align: left">Gds.so</td><td style="text-align: left">Gds::GdsComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/PLCnext_Runtime/GDS_Global_Data_Space.htm" title="PLCnext Info Center">Manages the global data space</a></td></tr>
<tr><td style="text-align: left">Retain.so</td><td style="text-align: left">Retain::RetainComponent</td><td style="text-align: left">Manages retentive variables</td></tr>
<tr><td style="text-align: left">Fbm.so</td><td style="text-align: left">Fbm::FbmComponent<br/>Fbm::FbIoComponent</td><td style="text-align: left">Fieldbus manager</td></tr>
</tbody></table>
</div>
<h3 id="service-components"><a class="header" href="#service-components">Service Components</a></h3>
<p>These components generally provide high-level, non real time features that are easily configurable by end users.</p>
<p>Library filename prefix: <code>libArp.Services.</code>
Component namespace: <code>Arp::Services</code></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Library filename</th><th style="text-align: left">Component type name</th><th style="text-align: left">Function</th></tr></thead><tbody>
<tr><td style="text-align: left">Alarms.so</td><td style="text-align: left">Alarms::AlarmsComponent</td><td style="text-align: left"><a href="https://plcnext.help/te/Functions_and_applications/Alarms.htm" title="PLCnext Info Center">Alarm dispatcher</a></td></tr>
<tr><td style="text-align: left">Fwm.so</td><td style="text-align: left">Fwm::FwmComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/WBM/Security_Firewall.htm" title="PLCnext Info Center">Firewall manager</a></td></tr>
<tr><td style="text-align: left">Wbm.so</td><td style="text-align: left">Wbm::WbmComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/WBM/WBM.htm" title="PLCnext Info Center">Web-based management</a></td></tr>
<tr><td style="text-align: left">Ehmi.so</td><td style="text-align: left">Ehmi::EhmiComponent</td><td style="text-align: left"><a href="https://plcnext.help/te/PLCnext_Engineer/Creating_a_PLCnext_Engineer_HMI_application.htm" title="PLCnext Info Center">Embedded HMI</a></td></tr>
<tr><td style="text-align: left">OpcUAServer.so</td><td style="text-align: left">OpcUAServer::OpcUAServerComponent</td><td style="text-align: left"><a href="https://plcnext.help/te/Communication_interfaces/OPC_UA/OPC_UA_server.htm" title="PLCnext Info Center">OPC UA server</a></td></tr>
<tr><td style="text-align: left">NotificationLogger.so</td><td style="text-align: left">NotificationLogger::NotificationLoggerComponent</td><td style="text-align: left"><a href="https://plcnext.help/te/Functions_and_applications/Notification_Logger.htm" title="PLCnext Info Center">Notification logger</a></td></tr>
<tr><td style="text-align: left">TraceController.so</td><td style="text-align: left">TraceController::TraceControllerComponent</td><td style="text-align: left"><a href="https://lttng.org/" title="LTTng">LTTng trace controller</a></td></tr>
<tr><td style="text-align: left">NmUtilities.so</td><td style="text-align: left">NmUtilities::NmPlcStateListener::NmPlcStateListenerComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/Service_Components/Notifications/Notification_manager.htm" title="PLCnext Info Center">Notification manager</a></td></tr>
<tr><td style="text-align: left">DataLogger.so</td><td style="text-align: left">DataLogger::DataLoggerComponent</td><td style="text-align: left"><a href="https://plcnext.help/te/Functions_and_applications/DataLogger_concept.htm" title="PLCnext Info Center">Data logger</a></td></tr>
<tr><td style="text-align: left">AppManager.so</td><td style="text-align: left">AppManager::AppManagerComponent</td><td style="text-align: left"><a href="https://www.plcnext.help/te/WBM/Administration_PLCnext_Apps.htm" title="PLCnext Info Center">PLCnext Store app management</a></td></tr>
<tr><td style="text-align: left">Fwu.so</td><td style="text-align: left">Fwu::FwuComponent</td><td style="text-align: left">Firmware update</td></tr>
<tr><td style="text-align: left">LinuxSyslog.so</td><td style="text-align: left">LinuxSyslog::LinuxSyslogComponent</td><td style="text-align: left">syslog-ng interface</td></tr>
<tr><td style="text-align: left">ProfiCloudV3.so</td><td style="text-align: left">ProfiCloudV3::ProfiCloudV3Component</td><td style="text-align: left"><a href="https://plcnext.help/te/Functions_and_applications/Proficloud_Connecting_to_the_service.htm" title="PLCnext Info Center">Proficloud</a></td></tr>
<tr><td style="text-align: left">Wcm.so</td><td style="text-align: left">Wcm::WcmComponent</td><td style="text-align: left">Web configuration management</td></tr>
<tr><td style="text-align: left">Logging.so</td><td style="text-align: left">Logging::LoggingComponent<br/>Logging::LogManagerComponent<br/>Logging::LogProviderComponent</td><td style="text-align: left">General event logger</td></tr>
<tr><td style="text-align: left">SpnsProxy.so</td><td style="text-align: left">SpnsProxy::SpnsProxyComponent</td><td style="text-align: left">Safety controller (SPNS) communications</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="component-instances"><a class="header" href="#component-instances">Component Instances</a></h2>
<p>When the PLCnext runtime starts, the following happens:</p>
<ol>
<li>One or more processes are started.</li>
<li>The libraries containing PLCnext component definitions are loaded into the specified process(es).</li>
<li>Component instances are created in the specified processes.</li>
</ol>
<p>The configuration information in this section appears in the following files:</p>
<ul>
<li><code>/etc/plcnext/device/Libraries.acf.config</code></li>
<li><code>/etc/plcnext/device/MainProcess.acf.config</code></li>
<li><code>/etc/plcnext/device/ExternalIoProcess.acf.config</code></li>
<li><code>/etc/plcnext/device/AXCF2152.acf.config</code></li>
</ul>
<h3 id="runtime-processes"><a class="header" href="#runtime-processes">Runtime Processes</a></h3>
<p>Most component instance are created in the main PLCnext runtime process, which is called <strong>MainProcess</strong>. In the AXC F 2152, one additional process is created, in which I/O component instances related to Axioline, Ethernet/IP and Interbus are created.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Process name</th><th style="text-align: left">Local TCP port</th></tr></thead><tbody>
<tr><td style="text-align: left">MainProcess</td><td style="text-align: left">41121</td></tr>
<tr><td style="text-align: left">ExternalIoProcess</td><td style="text-align: left">41123</td></tr>
<tr><td style="text-align: left">LocalIoProcess<sup>1</sup></td><td style="text-align: left">41124</td></tr>
</tbody></table>
</div>
<p><sup>1</sup> Only on AXC devices.</p>
<p>Since multiple Interbus and Profinet hardware interfaces are possible on an AXC F 2152 device, these additional processes allow the corresponding I/O networks to be dynamically assigned to the the correct hardware interface.</p>
<h3 id="component-libraries"><a class="header" href="#component-libraries">Component Libraries</a></h3>
<p>The following table show the alias given to each component library by the PLCnext runtime.</p>
<p>Libraries can be loaded conditionally, based on the value of a boolean environment variable. If no condition is specified, the library is always loaded.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Filename<br/>(libArp.*.so)</th><th style="text-align: left">Alias<br/>(Arp.*.Library)</th><th style="text-align: left">Condition</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>System.</strong></td><td style="text-align: left"><strong>System.</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Um</td><td style="text-align: left">Um</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">RscGateway</td><td style="text-align: left">RscGateway</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Commons.Services</td><td style="text-align: left">Commons.Services</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Security.Services</td><td style="text-align: left">Security.Services</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Fwu</td><td style="text-align: left">Fwu</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Watchdog</td><td style="text-align: left">SystemWatchdog</td><td style="text-align: left">ARP_COMPONENT_SYSTEM_WATCHDOG</td></tr>
<tr><td style="text-align: left">SysWatchdog</td><td style="text-align: left">SysWatchdog</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><strong>Hardware.</strong></td><td style="text-align: left"><strong>Hardware.</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Nim</td><td style="text-align: left">Nim</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">IdentificationData</td><td style="text-align: left">IdentificationData</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">FanControl</td><td style="text-align: left">FanControl</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Fpga</td><td style="text-align: left">Fpga</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">OsControl</td><td style="text-align: left">OsControl</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">RealTimeClock</td><td style="text-align: left">RealTimeClock</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ResourceMonitor</td><td style="text-align: left">ResourceMonitor</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">DeviceHmi</td><td style="text-align: left">DeviceHmi</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Sensors</td><td style="text-align: left">Sensors</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ExternalSDCard</td><td style="text-align: left">ExternalSDCard</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ExternalPci</td><td style="text-align: left">ExternalPci</td><td style="text-align: left">ARP_COMPONENT_EXTERNAL_PCI</td></tr>
<tr><td style="text-align: left"><strong>Device.</strong></td><td style="text-align: left"><strong>Device.</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">HmiLed</td><td style="text-align: left">HmiLed</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Interface</td><td style="text-align: left">Interface</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><strong>Plc.</strong></td><td style="text-align: left"><strong>Plc.</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Eclr</td><td style="text-align: left">Eclr</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Plm</td><td style="text-align: left">Plm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Esm</td><td style="text-align: left">Esm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Gds</td><td style="text-align: left">Gds</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Domain</td><td style="text-align: left">Domain</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Meta</td><td style="text-align: left">Meta</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Fbm</td><td style="text-align: left">Fbm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Retain</td><td style="text-align: left">Retain</td><td style="text-align: left">ARP_COMPONENT_RETAIN</td></tr>
<tr><td style="text-align: left"><strong>Services.</strong></td><td style="text-align: left"><strong>Services.</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Fwm</td><td style="text-align: left">Fwm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Wbm</td><td style="text-align: left">Wbm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Ehmi</td><td style="text-align: left">Ehmi</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">OpcUAServer</td><td style="text-align: left">OpcUAServer</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Alarms</td><td style="text-align: left">Alarms</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ProfiCloud</td><td style="text-align: left">ProfiCloud</td><td style="text-align: left">ARP_COMPONENT_PROFICLOUD</td></tr>
<tr><td style="text-align: left">ProfiCloudV3</td><td style="text-align: left">ProfiCloudV3</td><td style="text-align: left">ARP_COMPONENT_PROFICLOUD_V3</td></tr>
<tr><td style="text-align: left">NotificationLogger</td><td style="text-align: left">NotificationLogger</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">TraceController</td><td style="text-align: left">TraceController</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">NmUtilities</td><td style="text-align: left">NmUtilities</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">DataLogger</td><td style="text-align: left">DataLogger</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">AppManager</td><td style="text-align: left">AppManager</td><td style="text-align: left">ARP_COMPONENT_APPMANAGER</td></tr>
<tr><td style="text-align: left">LinuxSyslog</td><td style="text-align: left">LinuxSyslog</td><td style="text-align: left">ARP_COMPONENT_LINUXSYSLOG</td></tr>
<tr><td style="text-align: left">Wcm</td><td style="text-align: left">Wcm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Logging</td><td style="text-align: left">Logging</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">SpnsProxy</td><td style="text-align: left">SpnsProxy</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><strong>Io.</strong></td><td style="text-align: left"><strong>Io.</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ProfinetStack</td><td style="text-align: left">Pn</td><td style="text-align: left">ARP_COMPONENT_PROFINET<br/>or ARP_COMPONENT_PNC<br/>or ARP_COMPONENT_PND</td></tr>
<tr><td style="text-align: left">Axioline.so<sup>1</sup></td><td style="text-align: left">Axl</td><td style="text-align: left">ARP_COMPONENT_AXIOLINE</td></tr>
<tr><td style="text-align: left">Interbus.so<sup>1</sup></td><td style="text-align: left">IbM</td><td style="text-align: left">ARP_COMPONENT_INTERBUS</td></tr>
<tr><td style="text-align: left">EthernetIP.so<sup>1</sup></td><td style="text-align: left">EthernetIP</td><td style="text-align: left">ARP_COMPONENT_ETHERNETIP</td></tr>
</tbody></table>
</div>
<p><sup>1</sup> Only available on AXC devices.</p>
<h3 id="component-instances-1"><a class="header" href="#component-instances-1">Component Instances</a></h3>
<p>Each component created by the PLCnext runtime:</p>
<ul>
<li>Is created in a specific process. If no process is specified, the component is created in the main PLCnext Runtime process (&quot;MainProcess&quot;).</li>
<li>Can optionally be passed settings information. In the table below, all settings information represent files relative to the directory <code>/etc/plcnext/device</code>.</li>
<li>Can be created conditionally, based on the value of a boolean environment variable. If no condition is specified, the component instance is always created.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Instance name<br/>(Arp.*)</th><th style="text-align: left">Type<br/>(Arp::*)</th><th style="text-align: left">Process</th><th style="text-align: left">Settings information<br/>(<code>/etc/plcnext/device/*</code></th><th style="text-align: left">Condition</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>System.</strong></td><td style="text-align: left"><strong>System::</strong></td><td style="text-align: left"></td><td style="text-align: left"><strong>System/</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Commons.Services</td><td style="text-align: left">Commons::Services::Component</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Security.Services</td><td style="text-align: left">Security::Services::Component</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Watchdog.MainProcess</td><td style="text-align: left">Watchdog::SystemWatchdogComponent</td><td style="text-align: left"></td><td style="text-align: left">Watchdog/Watchdog.settings</td><td style="text-align: left">ARP_COMPONENT_SYSTEM_WATCHDOG</td></tr>
<tr><td style="text-align: left">RscGateway</td><td style="text-align: left">RscGateway::RscGatewayComponent</td><td style="text-align: left"></td><td style="text-align: left">RscGateway/RscGateway.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Um</td><td style="text-align: left">Um::UmComponent</td><td style="text-align: left"></td><td style="text-align: left">Um/Um.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Fwu</td><td style="text-align: left">Fwu::FwuComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Wcm</td><td style="text-align: left">Wcm::WcmComponent</td><td style="text-align: left"></td><td style="text-align: left">Wcm/Wcm.settings</td><td style="text-align: left">ARP_COMPONENT_WCM</td></tr>
<tr><td style="text-align: left"><strong>Hardware.</strong></td><td style="text-align: left"><strong>Hardware::</strong></td><td style="text-align: left"></td><td style="text-align: left"><strong>Hardware/</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">IdentificationData</td><td style="text-align: left">IdentificationData::IdentificationDataComponent</td><td style="text-align: left"></td><td style="text-align: left">IdentificationData/IdentificationData.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">FanControl</td><td style="text-align: left">FanControl::FanControlComponent</td><td style="text-align: left"></td><td style="text-align: left">FanControl/FanControl.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Fpga</td><td style="text-align: left">Fpga::FpgaComponent</td><td style="text-align: left"></td><td style="text-align: left">Fpga/Fpga.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">OsControl</td><td style="text-align: left">OsControl::OsControlComponent</td><td style="text-align: left"></td><td style="text-align: left">OsControl/OsControl.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">RealTimeClock</td><td style="text-align: left">RealTimeClock::RealTimeClockComponent</td><td style="text-align: left"></td><td style="text-align: left">RealTimeClock/RealTimeClock.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ResourceMonitor</td><td style="text-align: left">ResourceMonitor::ResourceMonitorComponent</td><td style="text-align: left"></td><td style="text-align: left">ResourceMonitor/ResourceMonitor.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">DeviceHmi</td><td style="text-align: left">DeviceHmi::DeviceHmiComponent</td><td style="text-align: left"></td><td style="text-align: left">DeviceHmi/DeviceHmi.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Sensors</td><td style="text-align: left">Sensors::SensorsComponent</td><td style="text-align: left"></td><td style="text-align: left">Sensors/Sensors.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Nim</td><td style="text-align: left">Nim::NimComponent</td><td style="text-align: left"></td><td style="text-align: left">Nim/Nim.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">NetloadLimiter</td><td style="text-align: left">Nim::NetloadLimiterComponent</td><td style="text-align: left"></td><td style="text-align: left">Nim/NetloadLimiter.settings</td><td style="text-align: left">ARP_COMPONENT_NETLOAD_LIMITER</td></tr>
<tr><td style="text-align: left">ExternalSDCard</td><td style="text-align: left">ExternalSDCard::ExternalSDCardComponent</td><td style="text-align: left"></td><td style="text-align: left">ExternalSDCard/ExternalSDCard.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ExternalPci</td><td style="text-align: left">ExternalPci::ExternalPciComponent</td><td style="text-align: left"></td><td style="text-align: left">ExternalPci/ExternalPci.settings</td><td style="text-align: left">ARP_COMPONENT_EXTERNAL_PCI</td></tr>
<tr><td style="text-align: left"><strong>Device.</strong></td><td style="text-align: left"><strong>Device::</strong></td><td style="text-align: left"></td><td style="text-align: left"><strong>Device/</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">HmiLed</td><td style="text-align: left">HmiLed::HmiLedComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Interface</td><td style="text-align: left">Interface::DiComponent</td><td style="text-align: left"></td><td style="text-align: left">Interface/Di.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><strong>Plc.</strong></td><td style="text-align: left"><strong>Plc::</strong></td><td style="text-align: left"></td><td style="text-align: left"><strong>Plc/</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Manager</td><td style="text-align: left">Domain::PlcManagerComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Domain</td><td style="text-align: left">Domain::PlcDomainComponent</td><td style="text-align: left"></td><td style="text-align: left">Domain/PlcDomain.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">MetaDomain</td><td style="text-align: left">Meta::MetaDomainComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Meta</td><td style="text-align: left">Meta::MetaComponent</td><td style="text-align: left"></td><td style="text-align: left">Meta/Meta.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">MetaController</td><td style="text-align: left">Meta::MetaControllerComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Eclr</td><td style="text-align: left">Eclr::EclrComponent</td><td style="text-align: left"></td><td style="text-align: left">Eclr/Eclr.settings</td><td style="text-align: left">ARP_COMPONENT_ECLR</td></tr>
<tr><td style="text-align: left">EclrServices</td><td style="text-align: left">Eclr::EclrServicesComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">ARP_COMPONENT_ECLR</td></tr>
<tr><td style="text-align: left">Eclr.ArpDomain</td><td style="text-align: left">Eclr::ArpDomainComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">ARP_COMPONENT_ECLR</td></tr>
<tr><td style="text-align: left">Plm</td><td style="text-align: left">Plm::PlmComponent</td><td style="text-align: left"></td><td style="text-align: left">Plm/Plm.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Esm</td><td style="text-align: left">Esm::EsmComponent</td><td style="text-align: left"></td><td style="text-align: left">Esm/Esm.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">EsmController</td><td style="text-align: left">Esm::EsmControllerComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Gds</td><td style="text-align: left">Gds::GdsComponent</td><td style="text-align: left"></td><td style="text-align: left">Gds/Gds.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Retain</td><td style="text-align: left">Retain::RetainComponent</td><td style="text-align: left"></td><td style="text-align: left">Retain/Retain.settings</td><td style="text-align: left">ARP_COMPONENT_RETAIN</td></tr>
<tr><td style="text-align: left">Fbm</td><td style="text-align: left">Fbm::FbmComponent</td><td style="text-align: left"></td><td style="text-align: left">Fbm/Fbm.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">DomainProxy.ExternalIoProcess</td><td style="text-align: left">Domain::PlcDomainProxyComponent</td><td style="text-align: left">ExternalIoProcess</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">DomainProxy.LocalIoProcess<sup>1</sup></td><td style="text-align: left">Domain::PlcDomainProxyComponent</td><td style="text-align: left">LocalIoProcess</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><strong>Io.</strong></td><td style="text-align: left"><strong>Plc::</strong></td><td style="text-align: left"></td><td style="text-align: left"><strong>Plc/</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">FbIo.PnC</td><td style="text-align: left">Fbm::FbIoComponent</td><td style="text-align: left"></td><td style="text-align: left">FbIo.PnC/FbIo.settings</td><td style="text-align: left">ARP_COMPONENT_PROFINET<br/>or ARP_COMPONENT_PNC</td></tr>
<tr><td style="text-align: left">FbIo.PnD</td><td style="text-align: left">Fbm::FbIoComponent</td><td style="text-align: left"></td><td style="text-align: left">FbIo.PnD/FbIo.settings</td><td style="text-align: left">ARP_COMPONENT_PROFINET<br/>or ARP_COMPONENT_PND</td></tr>
<tr><td style="text-align: left">FbIo.AxlC<sup>1</sup></td><td style="text-align: left">Fbm::FbIoComponent</td><td style="text-align: left"></td><td style="text-align: left">FbIo.AxlC/FbIo.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">FbIo.IbM<sup>1</sup></td><td style="text-align: left">Fbm::FbIoComponent</td><td style="text-align: left"></td><td style="text-align: left">FbIo.IbM/FbIo.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">FbIo.EthernetIP<sup>1</sup></td><td style="text-align: left">Fbm::FbIoComponent</td><td style="text-align: left"></td><td style="text-align: left">FbIo.EthernetIP/FbIo.settings</td><td style="text-align: left">ARP_COMPONENT_ETHERNETIP</td></tr>
<tr><td style="text-align: left"><strong>Io.</strong></td><td style="text-align: left"><strong>Io::</strong></td><td style="text-align: left"></td><td style="text-align: left"><strong>Io/</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">PnS</td><td style="text-align: left">ProfinetStack::System::SystemComponent</td><td style="text-align: left">ExternalIoProcess</td><td style="text-align: left">PnS/PnS.settings</td><td style="text-align: left">ARP_COMPONENT_PROFINET<br/>or ARP_COMPONENT_PNC<br/>or ARP_COMPONENT_PND</td></tr>
<tr><td style="text-align: left">PnC</td><td style="text-align: left">ProfinetStack::Controller::ControllerComponent</td><td style="text-align: left">ExternalIoProcess</td><td style="text-align: left">PnC/PnC.settings</td><td style="text-align: left">ARP_COMPONENT_PNC</td></tr>
<tr><td style="text-align: left">PnD</td><td style="text-align: left">ProfinetStack::Device::DeviceComponent</td><td style="text-align: left">ExternalIoProcess</td><td style="text-align: left">PnD/PnD.settings</td><td style="text-align: left">ARP_COMPONENT_PND</td></tr>
<tr><td style="text-align: left">AxlC<sup>1</sup></td><td style="text-align: left">Axioline::AxiolineComponent</td><td style="text-align: left"></td><td style="text-align: left">AxlC/AxlC.settings</td><td style="text-align: left">ARP_COMPONENT_AXIOLINE</td></tr>
<tr><td style="text-align: left">IbM<sup>1</sup></td><td style="text-align: left">Interbus::InterbusComponent</td><td style="text-align: left">LocalIoProcess</td><td style="text-align: left">IbM/IbM.settings</td><td style="text-align: left">ARP_COMPONENT_INTERBUS</td></tr>
<tr><td style="text-align: left">EthernetIP<sup>1</sup></td><td style="text-align: left">EthernetIP::EthernetIPComponent</td><td style="text-align: left">ExternalIoProcess</td><td style="text-align: left">EthernetIP/EthernetIP.settings</td><td style="text-align: left">ARP_COMPONENT_ETHERNETIP</td></tr>
<tr><td style="text-align: left"><strong>Services.</strong></td><td style="text-align: left"><strong>Services::</strong></td><td style="text-align: left"></td><td style="text-align: left"><strong>Services/</strong></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Alarms</td><td style="text-align: left">Alarms::AlarmsComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">Fwm</td><td style="text-align: left">Fwm::FwmComponent</td><td style="text-align: left"></td><td style="text-align: left">Fwm/Fwm.settings</td><td style="text-align: left">ARP_COMPONENT_FWM</td></tr>
<tr><td style="text-align: left">Wbm</td><td style="text-align: left">Wbm::WbmComponent</td><td style="text-align: left"></td><td style="text-align: left">Wbm/Wbm.settings</td><td style="text-align: left">ARP_COMPONENT_WBM</td></tr>
<tr><td style="text-align: left">Ehmi</td><td style="text-align: left">Ehmi::EhmiComponent</td><td style="text-align: left"></td><td style="text-align: left">Ehmi/ehmi.settings</td><td style="text-align: left">ARP_COMPONENT_EHMI</td></tr>
<tr><td style="text-align: left">OpcUAServer</td><td style="text-align: left">OpcUAServer::OpcUAServerComponent</td><td style="text-align: left"></td><td style="text-align: left">OpcUA/opcua.settings</td><td style="text-align: left">ARP_COMPONENT_OPC_UA</td></tr>
<tr><td style="text-align: left">ProfiCloud</td><td style="text-align: left">ProfiCloud::ProfiCloudComponent</td><td style="text-align: left"></td><td style="text-align: left">ProfiCloud/Proficloud.settings</td><td style="text-align: left">ARP_COMPONENT_PROFICLOUD</td></tr>
<tr><td style="text-align: left">ProfiCloudV3</td><td style="text-align: left">ProfiCloudV3::ProfiCloudV3Component</td><td style="text-align: left"></td><td style="text-align: left">ProfiCloudV3/ProfiCloudV3.settings</td><td style="text-align: left">ARP_COMPONENT_PROFICLOUD_V3</td></tr>
<tr><td style="text-align: left">NotificationLogger</td><td style="text-align: left">NotificationLogger::NotificationLoggerComponent</td><td style="text-align: left"></td><td style="text-align: left">NotificationLogger/NotificationLogger.settings</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">TraceController</td><td style="text-align: left">TraceController::TraceControllerComponent</td><td style="text-align: left"></td><td style="text-align: left">TraceController/TraceController.settings</td><td style="text-align: left">ARP_COMPONENT_TRACECONTROLLER</td></tr>
<tr><td style="text-align: left">NmUtilities.NmPlcStateListener</td><td style="text-align: left">NmUtilities::NmPlcStateListener::NmPlcStateListenerComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">DataLogger</td><td style="text-align: left">DataLogger::DataLoggerComponent</td><td style="text-align: left"></td><td style="text-align: left">DataLogger/dataLogger.settings</td><td style="text-align: left">ARP_COMPONENT_DATALOGGER</td></tr>
<tr><td style="text-align: left">AppManager</td><td style="text-align: left">AppManager::AppManagerComponent</td><td style="text-align: left"></td><td style="text-align: left">AppManager/AppManager.settings</td><td style="text-align: left">ARP_COMPONENT_APPMANAGER</td></tr>
<tr><td style="text-align: left">LinuxSyslog</td><td style="text-align: left">LinuxSyslog::LinuxSyslogComponent</td><td style="text-align: left"></td><td style="text-align: left">LinuxSyslog/LinuxSyslog.settings</td><td style="text-align: left">ARP_COMPONENT_LINUXSYSLOG</td></tr>
<tr><td style="text-align: left">Logging</td><td style="text-align: left">Logging::LoggingComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">ARP_COMPONENT_LOGGING</td></tr>
<tr><td style="text-align: left">LogManager</td><td style="text-align: left">Logging::LogManagerComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">ARP_COMPONENT_LOGMANAGER</td></tr>
<tr><td style="text-align: left">LogProvider</td><td style="text-align: left">Logging::LogProviderComponent</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">ARP_COMPONENT_LOGMANAGER</td></tr>
<tr><td style="text-align: left">SpnsProxy</td><td style="text-align: left">SpnsProxy::SpnsProxyComponent</td><td style="text-align: left"></td><td style="text-align: left">SpnsProxy/spnsproxy.settings</td><td style="text-align: left">ARP_COMPONENT_SPNSPROXY</td></tr>
</tbody></table>
</div>
<p><sup>1</sup> Only on AXC devices.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="disabling-features"><a class="header" href="#disabling-features">Disabling Features</a></h2>
<p>By default, the PLCnext runtime starts a large number of components. These components implement services or features on the device. In some circumstances it may be desirable to disable some of these features - for example, you want to free the resources that unused services would otherwise consume.</p>
<p>It is possible to disable some system features through the Web-Based Management (WBM) page of the device. This is described in the PLCnext Info Center:</p>
<p>https://www.plcnext.help/te/WBM/Configuration_System_Services.htm</p>
<p>In the next chapter, you will see how to add your own custom component to this list.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rsc-services"><a class="header" href="#rsc-services">RSC Services</a></h2>
<p>For PLCnext runtime features that are user configurable, configuration can usually be performed through either the web-based management interface, or modifying text files on the PLC.</p>
<p>Some PLCnext runtime features also provide an application programming interface (API) in the form of <em>Remote Service Calls</em>, or <a href="https://plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_Remote_Service_Calls.htm">RSC Services</a>.</p>
<p>A list of the RSC services that are available in the PLCnext runtime is given in <a href="appendix-02-list-of-rsc-services.html">Appendix B</a>.</p>
<p>RSC services can be accessed at least in two ways:</p>
<ul>
<li>Using an SDK to link to the relevant C++ shared object libraries. This provides local access to RSC services running on the same device as the C++ client.</li>
<li>Via <a href="https://grpc.io/">gRPC</a>, either locally via a Unix Domain Socket or remotely using Transport Layer Security (TLS).</li>
</ul>
<p>In the next chapter, you will:</p>
<ul>
<li>Write your own PLCnext runtime component.</li>
<li>Call RSC services from that component.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extension-components"><a class="header" href="#extension-components">Extension Components</a></h1>
<p>In the previous chapter, you saw how the PLCnext runtime uses factory-installed components to implement various functions.</p>
<p>It is possible to extend the PLCnext runtime with your own components. These are called <em>Extension Components</em> (also called <em>Internal Function Extensions</em>).</p>
<p>In this chapter, you will write your own extension component that is started by the PLCnext runtime, and learn more about the Application Component Framework (ACF) that makes this possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="simple-extension-component"><a class="header" href="#simple-extension-component">Simple Extension Component</a></h2>
<p>The simplest PLCnext component is a C++ class that inherits <a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1System_1_1Acf_1_1ComponentBase.html"><code>Arp::System::Acf::ComponentBase</code></a>.</p>
<p>The C++ source files (<code>.hpp</code> and <code>.cpp</code>) for a simple component, called <code>MyComponent</code>, can be downloaded here:</p>
<ul>
<li><a href="samples/ch04-01-simple-component/MyProject/src/MyComponent.hpp">MyComponent.hpp</a></li>
<li><a href="samples/ch04-01-simple-component/MyProject/src/MyComponent.cpp">MyComponent.cpp</a></li>
</ul>
<p>At this point <code>MyComponent</code> is a valid PLCnext Runtime component, but it contains no functionality - this will be added later.</p>
<h3 id="library-singleton"><a class="header" href="#library-singleton">Library Singleton</a></h3>
<p>Named component instances are created by the PLCnext runtime from a singleton that inherits <a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1System_1_1Acf_1_1LibraryBase.html"><code>Arp::System::Acf::LibraryBase</code></a>.</p>
<p>The C++ source files (<code>.hpp</code> and <code>.cpp</code>) for a singleton - called <code>MyLibrary</code> - that creates named instances of <code>MyComponent</code> can be downloaded here:</p>
<ul>
<li><a href="samples/ch04-01-simple-component/MyProject/src/MyLibrary.hpp">MyLibrary.hpp</a></li>
<li><a href="samples/ch04-01-simple-component/MyProject/src/MyLibrary.cpp">MyLibrary.cpp</a></li>
</ul>
<p>Note that both <code>MyComponent</code> and <code>MyLibrary</code> are defined in a namespace called <code>MyNamespace</code>.</p>
<h3 id="building-the-library"><a class="header" href="#building-the-library">Building the Library</a></h3>
<p>You can build a shared object library containing both these classes (<code>MyComponent</code> and <code>MyLibrary</code>) using the SDK that you installed earlier.</p>
<p>The following procedure uses the build tools <code>CMake</code> (version 3.19 or above) and <code>Ninja</code>, so make sure these are also installed on the host machine. The PLCnext CLI installs an older version of CMake which does not support the <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">cmake-presets</a> feature used in this procedure.</p>
<p>Build the library as follows:</p>
<ul>
<li>
<p>On your host machine, create a project directory. Under this directory, create a sub-directory called <code>src</code>.</p>
</li>
<li>
<p>Copy the four source files to the <code>src</code> directory.</p>
</li>
<li>
<p>In the project root directory, create a <code>CMakeLists.txt</code> file containing the following text:</p>
</li>
</ul>
<pre><code class="language-cmake">﻿cmake_minimum_required(VERSION 3.13)

project(MyProject)

if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE Release)
endif()

################# create target #######################################################

set (WILDCARD_SOURCE *.cpp)
set (WILDCARD_HEADER *.h *.hpp *.hxx)

file(GLOB_RECURSE Headers CONFIGURE_DEPENDS src/${WILDCARD_HEADER})
file(GLOB_RECURSE Sources CONFIGURE_DEPENDS src/${WILDCARD_SOURCE})
add_library(MyProject SHARED ${Headers} ${Sources})

#######################################################################################

################# project include-paths ###############################################

target_include_directories(MyProject
    PUBLIC
    $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src&gt;)

#######################################################################################

################# include arp cmake module path #######################################

list(INSERT CMAKE_MODULE_PATH 0 &quot;${ARP_TOOLCHAIN_CMAKE_MODULE_PATH}&quot;)

#######################################################################################

################# set link options ####################################################
# WARNING: Without --no-undefined the linker will not check, whether all necessary    #
#          libraries are linked. When a library which is necessary is not linked,     #
#          the firmware will crash and there will be NO indication why it crashed.    #
#######################################################################################

target_link_options(MyProject PRIVATE LINKER:--no-undefined)

#######################################################################################

################# add link targets ####################################################

find_package(ArpDevice REQUIRED)
find_package(ArpProgramming REQUIRED)

target_link_libraries(MyProject PRIVATE ArpDevice ArpProgramming)

#######################################################################################

################# install ############################################################

string(REGEX REPLACE &quot;^.*\\(([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+).*$&quot; &quot;\\1&quot; _ARP_SHORT_DEVICE_VERSION ${ARP_DEVICE_VERSION})
install(TARGETS MyProject
    LIBRARY DESTINATION ${ARP_DEVICE}_${_ARP_SHORT_DEVICE_VERSION}/$&lt;CONFIG&gt;/lib
    ARCHIVE DESTINATION ${ARP_DEVICE}_${_ARP_SHORT_DEVICE_VERSION}/$&lt;CONFIG&gt;/lib
    RUNTIME DESTINATION ${ARP_DEVICE}_${_ARP_SHORT_DEVICE_VERSION}/$&lt;CONFIG&gt;/bin)
unset(_ARP_SHORT_DEVICE_VERSION)

#######################################################################################
</code></pre>
<ul>
<li>Also in the project root directory, create a <code>CMakePresets.json</code> file containing the following text:</li>
</ul>
<pre><code class="language-json">{
    &quot;version&quot;: 3,
    &quot;cmakeMinimumRequired&quot;: {
        &quot;major&quot;: 3,
        &quot;minor&quot;: 19,
        &quot;patch&quot;: 0
    },
    &quot;configurePresets&quot;: [
        {
            &quot;name&quot;: &quot;default&quot;,
            &quot;hidden&quot;: true,
            &quot;displayName&quot;: &quot;Default Config&quot;,
            &quot;description&quot;: &quot;Default build using Ninja generator&quot;,
            &quot;generator&quot;: &quot;Ninja&quot;,
            &quot;toolchainFile&quot;: &quot;$env{PLCNEXT_SDK_ROOT}/toolchain.cmake&quot;,
            &quot;binaryDir&quot;: &quot;${sourceDir}/bin/$env{ARP_DEVICE}_$env{ARP_DEVICE_VERSION}&quot;,
            &quot;installDir&quot;: &quot;${sourceDir}/deploy&quot;,
            &quot;cacheVariables&quot;: {
                &quot;ARP_DEVICE&quot;: &quot;$env{ARP_DEVICE}&quot;,
                &quot;ARP_DEVICE_VERSION&quot;: &quot;$env{ARP_DEVICE_VERSION}&quot;,
                &quot;CMAKE_BUILD_WITH_INSTALL_RPATH&quot;: true
            }
        },
        {
            &quot;name&quot;: &quot;build-windows-AXCF2152-2021.9.0.40&quot;,
            &quot;inherits&quot;: &quot;default&quot;,
            &quot;displayName&quot;: &quot;AXCF2152-2021.9.0&quot;,
            &quot;environment&quot;: {
                &quot;ARP_DEVICE&quot;: &quot;AXCF2152&quot;,
                &quot;ARP_DEVICE_VERSION&quot;: &quot;2021.9.0 (21.9.0.40)&quot;,
                &quot;PLCNEXT_SDK_ROOT&quot;: &quot;C:\\SDK\\AXCF2152\\2021.9&quot;
            },
            &quot;condition&quot;: {
                &quot;type&quot;: &quot;equals&quot;,
                &quot;lhs&quot;: &quot;${hostSystemName}&quot;,
                &quot;rhs&quot;: &quot;Windows&quot;
            },
            &quot;cacheVariables&quot;: {
                &quot;CMAKE_TOOLCHAIN_FILE&quot;: {
                    &quot;value&quot;: &quot;$env{PLCNEXT_SDK_ROOT}/toolchain.cmake&quot;,
                    &quot;type&quot;: &quot;FILEPATH&quot;
                }
            }
        },
        {
            &quot;name&quot;: &quot;build-linux-AXCF2152-2021.9.0.40&quot;,
            &quot;inherits&quot;: &quot;default&quot;,
            &quot;displayName&quot;: &quot;AXCF2152-2021.9.0&quot;,
            &quot;environment&quot;: {
                &quot;ARP_DEVICE&quot;: &quot;AXCF2152&quot;,
                &quot;ARP_DEVICE_VERSION&quot;: &quot;2021.9.0 (21.9.0.40)&quot;,
                &quot;PLCNEXT_SDK_ROOT&quot;: &quot;/opt/pxc/sdk/AXCF2152/2021.9&quot;
            },
            &quot;condition&quot;: {
                &quot;type&quot;: &quot;equals&quot;,
                &quot;lhs&quot;: &quot;${hostSystemName}&quot;,
                &quot;rhs&quot;: &quot;Linux&quot;
            }
        }
    ],
    &quot;buildPresets&quot;: [
        {
            &quot;name&quot;: &quot;build-linux-AXCF2152-2021.9.0.40&quot;,
            &quot;displayName&quot;: &quot;AXCF2152-2021.9.0&quot;,
            &quot;configurePreset&quot;: &quot;build-linux-AXCF2152-2021.9.0.40&quot;
        }
    ],
    &quot;testPresets&quot;: [
        {
            &quot;name&quot;: &quot;default&quot;,
            &quot;configurePreset&quot;: &quot;default&quot;,
            &quot;output&quot;: {
                &quot;outputOnFailure&quot;: true
            },
            &quot;execution&quot;: {
                &quot;noTestsAction&quot;: &quot;error&quot;,
                &quot;stopOnFailure&quot;: true
            }
        }
    ]
}
</code></pre>
<p>You may need to change the ARP targets and SDK paths in this file to suit the setup of your development machine.</p>
<ul>
<li>
<p>From the project root directory, configure, build and deploy the project:</p>
<pre><code class="language-text">$ cmake --preset=build-linux-AXCF2152-2021.9.0.40
</code></pre>
<pre><code class="language-text">$ cmake --build --preset=build-linux-AXCF2152-2021.9.0.40 --target all
</code></pre>
<pre><code class="language-text">$ cmake --build --preset=build-linux-AXCF2152-2021.9.0.40 --target install
</code></pre>
</li>
</ul>
<p>You will see from the output that a shared object library, <code>libMyProject.so</code>, has been created. This contains the component called <code>MyNamespace::MyComponent</code> and the singleton called <code>MyNamespace::MyLibrary</code>.</p>
<ul>
<li>
<p>On the PLC, create a project directory e.g. <code>/opt/plcnext/projects/MyProject</code>, and a <code>lib</code> subdirectory.</p>
</li>
<li>
<p>Copy the shared object library from the host to the target:</p>
<pre><code class="language-text">$ scp deploy/AXCF2152_21.9.0.40/Release/lib/libMyProject.so admin@192.168.1.10:~/projects/MyProject/lib
</code></pre>
</li>
</ul>
<h3 id="instantiating-the-component"><a class="header" href="#instantiating-the-component">Instantiating the Component</a></h3>
<p>Now that the shared object library containing the extension component is on the target, the PLCnext runtime must be instructed to create an instance of <code>MyComponent</code>.</p>
<ul>
<li>On the host, in the project root directory, create a file named <code>MyProject.acf.config</code>, containing the following text:</li>
</ul>
<pre><code class="language-xml">﻿&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;AcfConfigurationDocument
  xmlns=&quot;http://www.phoenixcontact.com/schema/acfconfig&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.phoenixcontact.com/schema/acfconfig.xsd&quot;
  schemaVersion=&quot;1.0&quot; &gt;

  &lt;Processes&gt;
    &lt;Process name=&quot;MyProcess&quot; settingsPath=&quot;$ARP_ACF_SETTINGS_FILE$&quot; /&gt;
  &lt;/Processes&gt;

  &lt;Libraries&gt;
    &lt;Library name=&quot;MyProject&quot; binaryPath=&quot;$ARP_PROJECTS_DIR$/MyProject/lib/libMyProject.so&quot; /&gt;
  &lt;/Libraries&gt;

  &lt;Components&gt;
    &lt;Component name=&quot;MyComponentInstance&quot; type=&quot;MyNamespace::MyComponent&quot; library=&quot;MyProject&quot; process=&quot;MyProcess&quot; /&gt;
  &lt;/Components&gt;

&lt;/AcfConfigurationDocument&gt;
</code></pre>
<ul>
<li>
<p>Copy this ACF configuration file from the host to the target:</p>
<pre><code class="language-text">$ scp MyProject.acf.config admin@192.168.1.10:~/projects/Default
</code></pre>
<p>The PLCnext runtime will automatically load this configuration file, since the <code>Default.acf.config</code> file in the same directory includes all files that match the  pattern <code>*.acf.config</code>. The ACF configuration file for <code>MyProject</code> instructs the PLCnext runtime to:</p>
<ul>
<li>Create a new child process called <code>MyProcess</code>.</li>
<li>Load the shared object library and name it <code>MyProject</code>. This name can be considered an alias, or shorthand reference, to the shared object library. This name does not have any relationship to the name of the class in the shared object library that inherited <code>LibraryBase</code>.</li>
<li>Create an instance of <code>MyNamespace::MyComponent</code>, called <code>MyComponentInstance</code>, from the library named <code>MyProject</code>, in the process named <code>MyProcess</code>.</li>
</ul>
<p>The <code>process</code> parameter is optional and, if omitted, the component instance will be created in the main PLCnext Runtime process (called <code>MainProcess</code>).</p>
</li>
<li>
<p>Restart the PLCnext runtime:</p>
<pre><code class="language-text"># sudo /etc/init.d/plcnext restart &amp;&amp; tail -f -n 0 /opt/plcnext/logs/Output.log
(result)
</code></pre>
</li>
</ul>
<p>Among the messages that appear in the <code>Output.log</code> file, you should see the following:</p>
<pre><code class="language-text">INFO  - Process 'MyProcess' started successfully.
</code></pre>
<pre><code class="language-text">INFO  - Library 'MyProject' in process 'MyProcess' loaded.
</code></pre>
<pre><code class="language-text">INFO  - Component 'MyComponentInstance' in process 'MyProcess' created.
</code></pre>
<p>Your first PLCnext runtime extension component instance is now running!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="component-library-singleton"><a class="header" href="#component-library-singleton">Component Library Singleton</a></h2>
<p>You won't need to worry too much about the <code>MyLibrary</code> singleton that you created with your extension component. This singleton provides a way for the PLCnext runtime to create named instances of your ACF component(s).</p>
<p>Each shared object file must only contain one singleton that inherits <code>LibraryBase</code>. This singleton can usually remain unchanged as you develop your components. The only time that this singleton must be modified is when you add or remove components from your library.</p>
<p>To add a component to the library:</p>
<ul>
<li>
<p>Create the new component in your C++ project. These two source files contain the definition for a component named <code>MyOtherComponent</code>, which you can add to the <code>src</code> directory of the project you created in the previous section:</p>
<ul>
<li><a href="samples/ch04-02-library-singleton/MyProject/src/MyOtherComponent.hpp">MyOtherComponent.hpp</a></li>
<li><a href="samples/ch04-02-library-singleton/MyProject/src/MyOtherComponent.cpp">MyOtherComponent.cpp</a></li>
</ul>
</li>
<li>
<p>Add the header file for <code>MyOtherComponent</code> to the library <code>.cpp</code> file.</p>
</li>
<li>
<p>In the library constructor, add a call to the method <code>componentFactory.AddFactoryMethod</code> to register the new component.</p>
<p>The new library source file can be downloaded here:</p>
<ul>
<li><a href="samples/ch04-02-library-singleton/MyProject/src/MyLibrary.cpp">MyLibrary.cpp</a></li>
</ul>
</li>
<li>
<p>Rebuild the project and copy the resulting <code>.so</code> file to the target.</p>
</li>
<li>
<p>You can create an instance of MyOtherComponent by adding a new entry to the .acf.config file, as follows:</p>
<pre><code class="language-xml"> &lt;Component name=&quot;MyOtherComponentInstance&quot; type=&quot;MyNamespace::MyOtherComponent&quot; library=&quot;MyProject&quot; process=&quot;MyProcess&quot; /&gt;
</code></pre>
</li>
<li>
<p>Copy the new configuration file to the target and restart the PLCnext runtime. You will now see these entries in the Output.log file:</p>
</li>
</ul>
<pre><code class="language-text">INFO  - Component 'MyComponentInstance' in process 'MainProcess' created.
INFO  - Component 'MyOtherComponentInstance' in process 'MainProcess' created.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="component-methods"><a class="header" href="#component-methods">Component Methods</a></h2>
<p>After completing the previous sections, an instance of your PLCnext extension component - called <code>MyComponentInstance</code> - has been created by the PLCnext runtime. At the moment, this component instance is not doing much. The PLCnext runtime has called a number of the methods that you defined in the <code>MyComponent</code> class, but because these methods are empty, we don't see any evidence that this has happened. Let's write some messages to the <code>Output.log</code> file, so we can see when these methods are called.</p>
<p>One way that our component instance can write to the Output.log file is if it inherits a base class created from the template <a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1System_1_1Commons_1_1Diagnostics_1_1Logging_1_1Loggable_3_01Derived_00_01true_01_4.html"><code>Arp::System::Commons::Diagnostics::Logging::Loggable</code></a>.</p>
<p>The main steps to do this are:</p>
<ul>
<li>
<p>Add the header file to the .hpp file of our component:</p>
<pre><code class="language-cpp">#include &quot;Arp/System/Commons/Logging.h&quot;
</code></pre>
</li>
<li>
<p>Inherit the <code>Loggable</code> template class, by adding the following to the component class definition:</p>
<pre><code class="language-cpp">private Loggable&lt;MyComponent&gt;
</code></pre>
<p>The component class thereby inherits a private field - called <code>log</code> - of type <a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1System_1_1Commons_1_1Diagnostics_1_1Logging_1_1Log.html">Arp::System::Commons::Diagnostics::Logging::Log</a>.</p>
</li>
<li>
<p>Add log messages where required.</p>
<p>In this case, we have added a log message to every method in the component's <code>.cpp</code> file. The resulting source files are available here:</p>
<ul>
<li><a href="samples/ch04-03-component-methods/MyProject/src/MyComponent.hpp">MyComponent.hpp</a></li>
<li><a href="samples/ch04-03-component-methods/MyProject/src/MyComponent.cpp">MyComponent.cpp</a></li>
</ul>
<p>You can use these files to update the project you created in the previous section.</p>
</li>
<li>
<p>Rebuild the project.</p>
</li>
<li>
<p>Copy the resulting library file to the target.</p>
</li>
<li>
<p>Restart the PLCnext runtime:</p>
<pre><code class="language-text"># sudo /etc/init.d/plcnext restart &amp;&amp; tail -f -n 0 /opt/plcnext/logs/Output.log
</code></pre>
</li>
</ul>
<p>Among the messages that appear in the Output.log file, you should see the following:</p>
<pre><code class="language-text">INFO  - MyComponent::Initialize
INFO  - MyComponent::SubscribeServices
INFO  - MyComponent::LoadSettings - settings path = ''
INFO  - MyComponent::SetupSettings
INFO  - MyComponent::PublishServices
INFO  - MyComponent::LoadConfig
INFO  - MyComponent::SetupConfig
</code></pre>
<p>These methods are called, in sequence, when the component instance is created by the PLCnext runtime. Other methods are called when the PLCnext runtime shuts down, just before the component instance is destroyed. Some types of components even have methods that are called during normal PLCnext runtime operation, under certain circumstances. For example, it is possible for a component to be notified when the PLC component - which executes deterministic, real-time tasks - stops and restarts.</p>
<p>Each of these methods allows the component to perform one or more common functions, if required, at the appropriate time. For example, the <code>SubscribeServices</code> method, as the name suggests, is a good place for the component to subscribe to any RSC services that it needs to use.</p>
<p>The table below shows when <code>ComponentBase</code> methods are called on ACF components. It is based on a <a href="https://plcnext.help/te/Programming/Cplusplus/PLM_Program_Library_Manager.htm">similar table in the PLCnext Info Center</a>.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Method</th><th style="text-align: left">Called on an ACF component …</th></tr></thead><tbody>
<tr><td style="text-align: left">Initialize<br/>SubscribeServices<br/>LoadSettings<br/>SetupSettings<br/>PublishServices</td><td style="text-align: left">During the first stage of ACF startup *</td></tr>
<tr><td style="text-align: left">LoadConfig<br/>SetupConfig<br/></td><td style="text-align: left">During the second stage of ACF startup *</td></tr>
<tr><td style="text-align: left">ResetConfig</td><td style="text-align: left">During the first stage of ACF shutdown</td></tr>
<tr><td style="text-align: left">Dispose</td><td style="text-align: left">During the second stage of ACF shutdown</td></tr>
<tr><td style="text-align: left">PowerDown</td><td style="text-align: left">Only when an unexpected power loss occurs,<br/>and only on devices that have a power status sensor</td></tr>
</tbody></table>
</div>
<p>In the above table, all the methods listed in the sections marked with * are called one after the other on each component instance in the order listed, so in practice it makes no difference in which of these method(s) the user chooses to implement their application-specific code.</p>
<p>You can see that only one of the standard component methods has a parameter. The <code>const String&amp;</code> parameter on the <code>LoadSettings</code> method allows this method to receive a string value. This parameter is generally used by firmware components to get the path to a settings file - hence the parameter name. However, you can use this parameter to pass <em>any</em> string information to your component instance during startup:</p>
<ul>
<li>
<p>In the <code>.acf.config</code> file, replace this line:</p>
<pre><code class="language-xml">  &lt;Component name=&quot;MyComponentInstance&quot; type=&quot;MyNamespace::MyComponent&quot; library=&quot;MyProject&quot; process=&quot;MyProcess&quot; /&gt;
</code></pre>
<p>... with these lines:</p>
<pre><code class="language-xml">  &lt;Component name=&quot;MyComponentInstance&quot; type=&quot;MyNamespace::MyComponent&quot; library=&quot;MyProject&quot; process=&quot;MyProcess&quot;&gt;
    &lt;Settings path=&quot;Settings data&quot; /&gt;
  &lt;/Component&gt;
</code></pre>
</li>
<li>
<p>Copy the <code>.acf.config</code> file to the target, and restart the PLCnext runtime.</p>
</li>
</ul>
<p>You should now see a line in the <code>Output.log</code> file with this message:</p>
<pre><code class="language-text">INFO  - MyComponent::LoadSettings - settings path = 'Settings data'
</code></pre>
<p>Using this method, it is possible to pass user-configurable String data to the component during component startup.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="using-rsc-services"><a class="header" href="#using-rsc-services">Using RSC Services</a></h2>
<p><a href="ch03-06-rsc-services.html">Previously</a> you learned that some PLCnext runtime features provide an application programming interface (API) in the form of <em>Remote Service Calls</em>, or RSC Services.</p>
<p>In this section, our ACF component will call C++ API on the <a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1Device_1_1Interface_1_1Services_1_1IDeviceInfoService.html">Device Info</a> RSC service. The Device Info service provides access to <a href="https://www.plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_device_interface_services.htm#IDeviceInfoService" title="PLCnext Info Center">Device Information</a>. You can use a similar technique to access <a href="appendix-02-list-of-rsc-services.html">any RSC service</a> in the PLCnext Runtime.</p>
<p>Here are the steps to use the C++ API on the Device Info RSC service:</p>
<ul>
<li>
<p>Add the relevant header file to the .hpp file of the component:</p>
<pre><code class="language-cpp">#include &quot;Arp/Device/Interface/Services/IDeviceInfoService.hpp&quot;
</code></pre>
</li>
<li>
<p>Declare a pointer to the Device Info service:</p>
<pre><code class="language-cpp">IDeviceInfoService::Ptr deviceInfoServicePtr = nullptr;
</code></pre>
</li>
<li>
<p>In the component .cpp file, add the header for the RSC Service Manager:</p>
<pre><code class="language-cpp">#include &quot;Arp/System/Rsc/ServiceManager.hpp&quot;
</code></pre>
</li>
<li>
<p>In the <code>SubscribeServices</code> method of the ACF component, get a pointer to the Device Info service:</p>
<pre><code class="language-cpp">this-&gt;deviceInfoServicePtr = ServiceManager::GetService&lt;IDeviceInfoService&gt;();
</code></pre>
</li>
<li>
<p>In the <code>SetupConfig</code> method of the ACF component, use the Device Info service to read the device serial number, and log the value to the <code>Output.log</code> file:</p>
<pre><code class="language-cpp">RscVariant&lt;512&gt; serialNumber = this-&gt;deviceInfoServicePtr-&gt;GetItem(&quot;General.SerialNumber&quot;);
if (serialNumber.GetType() == RscType::String)
{
   this-&gt;log.Info(&quot;Serial number of this device: {0}%&quot;, serialNumber.GetChars());
}
else this-&gt;log.Info(&quot;Error reading device serial number&quot;);
</code></pre>
</li>
<li>
<p>The above code is included in these source files:</p>
<ul>
<li><a href="samples/ch04-04-using-rsc-services/MyProject/src/MyComponent.hpp">MyComponent.hpp</a></li>
<li><a href="samples/ch04-04-using-rsc-services/MyProject/src/MyComponent.cpp">MyComponent.cpp</a></li>
</ul>
<p>You can use these files to update the project you created in the previous section.</p>
</li>
<li>
<p>Rebuild the project.</p>
</li>
<li>
<p>Copy the resulting library file to the target.</p>
</li>
<li>
<p>Restart the PLCnext runtime:</p>
<pre><code class="language-text"># sudo /etc/init.d/plcnext restart &amp;&amp; tail -f -n 0 /opt/plcnext/logs/Output.log
</code></pre>
</li>
</ul>
<p>Among the messages that appear in the <code>Output.log</code> file, you should see an INFO message from your component containing the serial number of your device.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="worker-threads"><a class="header" href="#worker-threads">Worker Threads</a></h2>
<p>After completing the previous section, you may have your eye on another quite interesting RSC service - the <a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1Plc_1_1Gds_1_1Services_1_1IDataAccessService.html">Data Access</a> service. This service provides access to <a href="https://www.plcnext.help/te/PLCnext_Runtime/GDS_Global_Data_Space.htm" title="PLCnext Info Center">Global Data Space</a> (GDS) variables in the PLCnext runtime.</p>
<p>Many variables in the GDS will change over time, and it may be necessary for an ACF component to exchange data with GDS variables during the lifetime of the component. However, the only component methods we have seen so far are called during the startup or shutdown of the component. It would be useful to have a component method that is executed periodically during the complete lifetime of the component, so that (for example) data can be exchanged with GDS variables using the Data Access service.</p>
<p>The ARP provides a <a href="https://api.plcnext.help/api_docs_2021-0-LTS/classArp_1_1System_1_1Commons_1_1Threading_1_1WorkerThread.html"><em>worker thread</em></a> class that can be used for this purpose. An ACF component can create a worker thread and, in the thread constructor, specify:</p>
<ul>
<li>an execution frequency, and</li>
<li>a method that will be executed on the worker thread at that frequency.</li>
</ul>
<p><a href="https://github.com/PLCnext/CppExamples/tree/master/Examples/ThreadExample">An example</a> of how to use worker threads (and other types of ARP threads) is provided in Github.</p>
<blockquote>
<p>ARP threads, including worker threads, are not designed to be used for &quot;real time&quot; processing. Worker threads should not be confused with Cyclic Tasks in a PLC. The execution period of a worker thread is not deterministic, and the actual execution frequency cannot be guaranteed.</p>
</blockquote>
<p>For applications where a deterministic task cycle is not required, a worker thread may be a good solution.</p>
<p>Many of the <a href="https://github.com/PLCnext/CppExamples">C++ examples in Github</a> use a worker thread to call various RSC services. For example, the <a href="https://github.com/PLCnext/CppExamples/blob/master/Examples/DataAccess">Data Access example</a> uses a worker thread to read and write GDS variable data using the Data Access service.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creating-gds-variables---part-1"><a class="header" href="#creating-gds-variables---part-1">Creating GDS variables - Part 1</a></h2>
<p>You have seen how the Global Data Space (GDS) provides a simple way to exchange data between otherwise isolated PLCnext runtime components.</p>
<p>It is possible for your own component instance to create variables in the GDS. These variables can then be accessed by other PLCnext runtime components using (for example) the Data Access RSC service, as discussed the previous section.</p>
<p>GDS variables can also:</p>
<ul>
<li>be included in the OPC UA server address space,</li>
<li>have their value persisted (or &quot;retained&quot;) across restarts of the PLCnext runtime,</li>
<li>have their value logged to a Proficloud Time Series Data (TSD) service,</li>
<li>be accessed through a REST API,</li>
<li>be used on web-based HMI pages,</li>
<li>be used to exchange data with physical I/O modules.</li>
</ul>
<p>In order for a component to create its own variables in the GDS, the component must inherit from <code>MetaComponentBase</code>, rather than from <code>ComponentBase</code>. The library class must also inherit from <code>MetaLibraryBase</code>. Additional code must also be added to the library and the component class, e.g. the <code>RegisterComponentPorts</code> method must be implemented in the component.</p>
<p>Rather than making these changes to the source code manually, we will make use of the tool you probably used to install the SDK - the PLCnext Command Line Interface, or <code>plcncli</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="plcnext-cli"><a class="header" href="#plcnext-cli">PLCnext CLI</a></h2>
<p>You <a href="ch01-04-installing-a-software-development-kit.html">previously</a> used the PLCnext CLI to install the SDK that you have been using to build your C++ projects for the target. However, the PLCnext CLI does more than just manage SDKs.</p>
<p>You can read more about the features of the PLCnext CLI in the <a href="https://plcnext.help/te/Programming/PLCnext_toolchain/Installing_PLCnext_toolchain.htm">PLCnext Info Center</a>. These features include:</p>
<h3 id="code-generation"><a class="header" href="#code-generation">Code Generation</a></h3>
<p>PLCnext CLI can automatically generate code in a number of scenarios.</p>
<h4 id="initial-project-setup"><a class="header" href="#initial-project-setup">Initial project setup</a></h4>
<p>The PLCnext CLI can generate customised C++ source and configuration files for different types of projects, based on code templates in the <code>Templates</code> directory (in the plcncli installation directory). This is useful when starting a new C++ project that targets a PLCnext Control device.</p>
<p>The templates that are installed with the PLCnext CLI are also available <a href="https://github.com/PLCnext/PLCnext_CLI_Templates">in Github</a>.</p>
<p>It is possible to create your own code templates that can be used with the PLCnext CLI. At the moment the required structure of PLCnext CLI templates <a href="https://github.com/PLCnext/PLCnext_CLI_Templates/issues/1">is not documented</a>, but this is planned for the future.</p>
<h4 id="add-components-and-programs-to-a-project"><a class="header" href="#add-components-and-programs-to-a-project">Add components and programs to a project</a></h4>
<p>There are PLCnext CLI commands for adding C++ components and programs to an existing project. These commands are useful when your C++ project requires more than the single C++ component and/or program that are created by the PLCnext CLI in a new C++ project.</p>
<h4 id="generate-intermediate-code"><a class="header" href="#generate-intermediate-code">Generate 'intermediate' code</a></h4>
<p>Intermediate code includes &quot;boilerplate&quot; C++ code that is required for a PLCnext runtime project, but which can be generated automatically e.g by parsing the C++ components and programs in that project. Intermediate files include:</p>
<ul>
<li>The <a href="ch04-02-library-singleton.html">Library singleton</a> that is required in a PLCnext runtime library.</li>
<li>Code required to create GDS variables for your C++ component and/or program in the Global Data Space.</li>
</ul>
<blockquote>
<p>You should not edit any of the intermediate files that are auto-generated by the PLCnext CLI. These files are regenerated whenever the <code>plcncli generate</code> command is executed, and at that point any manual changes to those files will be lost.</p>
</blockquote>
<h3 id="managing-build-targets"><a class="header" href="#managing-build-targets">Managing build target(s)</a></h3>
<p>Each C++ project generated by the PLCnext CLI includes a list of build targets for that project. This list can be managed using <code>plcncli</code> commands.</p>
<h3 id="building-the-project"><a class="header" href="#building-the-project">Building the project</a></h3>
<p>The PLCnext CLI can build a C++ project for the selected target(s) with one command - <code>plcncli build</code>.</p>
<p>The next section will use the PLCnext CLI to create and build a C++ project containing one ACF component.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creating-gds-variables---part-2"><a class="header" href="#creating-gds-variables---part-2">Creating GDS variables - Part 2</a></h2>
<p>Now that we have seen how the PLCnext CLI can help us, let's use it to create a project containing an ACF component that creates some GDS variables.</p>
<ul>
<li>
<p>Create a new project on the host system:</p>
<pre><code class="language-text">$ plcncli new acfproject --name MyGdsProject --namespace MyNamespace --component MyComponent --verbose
</code></pre>
</li>
<li>
<p>Set the build target for the project:</p>
<pre><code class="language-text">$ cd MyGdsProject
$ plcncli set target --add --name AXCF2152 --version 2021.9
</code></pre>
<p>If the target is ambiguous or cannot be found, you can use the following command to see the list of installed targets that the PLCnext CLI knows about:</p>
<pre><code class="language-text">$ plcncli get targets
</code></pre>
</li>
<li>
<p>Edit the source code using your favourite editor. In this case we will use <a href="https://code.visualstudio.com/">Visual Studio Code</a>:</p>
<pre><code class="language-text">$ code .
</code></pre>
<p>You can see that the PLCnext CLI has created the following source and configuration files in the <code>MyGdsProject</code> directory:</p>
<pre><code class="language-text">├── CMakeLists.txt
├── external
│   └── ADD_DEPENDENT_LIBRARIES_HERE.txt
├── How_to_deploy.txt
├── plcnext.proj
└── src
    ├── MyComponent.cpp
    ├── MyComponent.hpp
    └── MyGdsProjectLibrary.acf.config
</code></pre>
</li>
<li>
<p>Add a GDS variable to the section indicated in the component <code>.hpp</code> file:</p>
<pre><code class="language-cpp">//#port
Arp::uint8 MyGdsVariable;
</code></pre>
<p>GDS variables are also referred to as &quot;ports&quot;. The <a href="https://plcnext.help/te/Programming/Cplusplus/IComponent_and_IProgram.htm">PLCnext Info Center</a> provides detailed information on GDS port definitions in C++ code, including the attributes that can be applied to GDS ports defined in this way.</p>
</li>
<li>
<p>Change the <code>.acf.config</code> file if necessary, e.g. the path to the shared object library file.</p>
</li>
<li>
<p>Save the edited file(s)</p>
</li>
<li>
<p>On the command-line, use the PLCnext CLI to generate the intermediate files for the project:</p>
<p>$ plcncli generate code --verbose</p>
<p>You can see that the PLCnext CLI has now created a lot of files in the <code>MyGdsProject</code> directory, including the following:</p>
<pre><code class="language-text">├── intermediate
│   └── code
│       ├── MyComponent.meta.cpp
│       ├── MyGdsProjectLibrary.cpp
│       ├── MyGdsProjectLibrary.hpp
│       └── MyGdsProjectLibrary.meta.cpp
</code></pre>
<p>These C++ source files contain additional code required for the PLCnext runtime to create instances of the C++ component and its GDS port(s).</p>
</li>
<li>
<p>Build the project:</p>
<pre><code class="language-text">$ plcncli build --verbose
</code></pre>
<p>This command uses CMake to build the project for all the specified targets.</p>
</li>
<li>
<p>Deploy the shared object library and the <code>.acf.config</code> file to the PLC as you've done <a href="ch04-01-simple-component.html">previously</a>.</p>
</li>
<li>
<p>Restart the PLCnext Runtime.</p>
</li>
</ul>
<p>Your ACF component instance now includes a GDS port in the Global Data Space that can be accessed by other components using the Data Access RSC service.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="connecting-gds-variables"><a class="header" href="#connecting-gds-variables">Connecting GDS Variables</a></h2>
<p>Consider the following question:</p>
<p>You have an ACF component that needs to know the current average CPU load of the device it's running on. The component starts a worker thread that executes a method periodically. How can that method read the average CPU load of the device?</p>
<p>Using what you've learned so far in this chapter, you might consider two possible solutions:</p>
<ol>
<li>
<p>Use the <code>GetItem</code> method on the <a href="https://plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_device_interface_services.htm#IDeviceStatusService">Device Status RSC service</a> to read the CPU load of the device, using the <code>Status.Cpu.0.Load.Percent</code> item specifier.</p>
</li>
<li>
<p>Use the <code>ReadSingle</code> method on the <a href="https://plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_GDS_services.htm#IDataAccessService">Data Access RSC service</a> to read the CPU load of the device from the GDS port variable named <code>Arp.Plc.Eclr/DEVICE_STATE.CPU_LOAD_ALL_CORES</code>.</p>
</li>
</ol>
<p>Those are both perfectly acceptable solutions, but in this case there is a third, simpler solution.</p>
<p>The GDS component in the PLCnext Runtime provides the facility to &quot;connect&quot; any GDS OUT ports to any GDS IN port(s) of compatible type, without any code. Once these ports connections are configured, the PLCnext runtime will automatically transfer data from each IN port to each connected OUT port.</p>
<p>The steps to do this are:</p>
<ul>
<li>
<p>Starting with the example in the previous section, add a worker thread that periodically executes a method that prints the value of <code>MyGdsVariable</code> to the <code>Output.log</code> file.</p>
</li>
<li>
<p>In the project <code>src</code> directory, create a file named <code>MyGdsProject.gds.config</code>, containing the following:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;GdsConfigurationDocument xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; schemaVersion=&quot;1.0&quot; xmlns=&quot;http://www.phoenixcontact.com/schema/gdsconfig&quot;&gt;
  &lt;ComponentTaskRelations /&gt;
  &lt;Connectors&gt;
    &lt;Connector startPort=&quot;Arp.Plc.Eclr/DEVICE_STATE.CPU_LOAD_ALL_CORES&quot; endPort=&quot;MyComponent1/MyGdsVariable&quot; /&gt;
  &lt;/Connectors&gt;
&lt;/GdsConfigurationDocument&gt;
</code></pre>
<p>This configuration file will create a GDS port connector that will automatically transfer data between the <code>startPort</code> and the <code>endPort</code>. In this case the <code>endPort</code> is the GDS port on your component instance.</p>
</li>
<li>
<p>Build and deploy your project in the usual way.</p>
</li>
<li>
<p>Copy the GDS configuration file from the host to the target:</p>
<pre><code class="language-text">$ scp src/MyGDSProject.acf.config admin@192.168.1.10:~/projects/Default/Plc/Gds
</code></pre>
<p>The PLCnext runtime will automatically load all files in this destination directory that match the pattern <code>*.gds.config</code> (this is specified in the file <code>/etc/plcnext/device/Plc/Gds/Gds.settings</code>).</p>
</li>
<li>
<p>Restart the PLCnext runtime.</p>
<p>You should now see the value of the CPU load appearing in the <code>Output.log</code> file.</p>
</li>
</ul>
<p>A benefit of this file-based configuration technique is that the <code>.gds.config</code> file can include I/O ports - that is, GDS port variables that are used to exchange data with inputs and outputs on physical I/O modules. The Data Access RSC service, on the other hand, cannot exchange data directly with I/O port variables.</p>
<p>One disadvantage of this technique is that the names of all the GDS ports must be known at design-time, since variable names must appear in a <code>.gds.config</code> file. When using the Data Access RSC service, on the other hand, the name of each GDS port is passed as a String variable, and so can be specified at run-time.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="interactive-course"><a class="header" href="#interactive-course">Interactive Course</a></h2>
<p>You can sharpen up your knowledge on the topics that have been covered in this chapter by working through the interactive online course <a href="https://elearning.plcnext.help/PLCnTech_IntFuncExt/story.html"><em>Internal Function Extensions</em></a> on the PLCnext Community website.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-time-programming"><a class="header" href="#real-time-programming">Real Time Programming</a></h1>
<p>The previous chapter showed how to write PLCnext runtime applications that do not require real-time, deterministic performance. The priority of the process executing ACF components (including worker threads) is no higher than other threads or processes on the device, and as a result the &quot;jitter&quot; - or the variation in the execution period - is likely to be very high for worker threads. This is fine for many applications, but some applications require a more deterministic execution period, like is available on traditional PLCs.</p>
<p>The Linux kernel on PLCnext Control devices includes the <a href="https://wiki.linuxfoundation.org/realtime/start">PREEMPT-RT patch</a>, so it is possible to execute code with real-time priority. On its own, the use of this feature requires extensive experience of C++ and POSIX thread handling.</p>
<p>Luckily for us, the PLCnext runtime includes a set of <em>PLC</em> components, which allow users to easily implement C++ applications that have the same deterministic performance as applications on traditional PLCs. One of these PLCnext runtime components is the Execution and Synchronisation Manager (ESM), which - as the name suggests - is responsible for scheduling and executing real-time tasks.</p>
<p>The ESM uses terminology from the <a href="https://en.wikipedia.org/wiki/IEC_61131">IEC 61131</a> standard, which PLC programmers will be familiar with. For example, a <em>program</em> is a piece of code that will be executed in real time. One or more named <em>program instances</em> are created in a <em>task</em>. Tasks can be executed cyclically with a fixed period, or executed when other criteria are satisfied e.g. on a specified event. When a task is executed, the program instances defined in that task will be executed one after the other, in the order specified. It is possible for a PLC application to contain multiple tasks. On PLCnext Control devices, it is possible to assign tasks to one of multiple ESM instances. Each ESM instance corresponds to a core on the device CPU, so (for example) an AXC F 2152 with two CPU cores has two ESM instances in the PLCnext runtime.</p>
<p>There is more information about the ESM in the <a href="https://www.plcnext.help/te/PLCnext_Runtime/ESM.htm">PLCnext Info Center</a>.</p>
<p>In the previous chapter we saw how to configure the Global Data Space using a <code>.gds.config</code> file in XML format. The ESM is configured in a similar way, using an <code>.esm.config</code> file. This configuration file:</p>
<ul>
<li>Defines real-time tasks.</li>
<li>Assigns each task to an ESM instance.</li>
<li>Defines real-time program instances.</li>
<li>Assigns program instances to tasks.</li>
</ul>
<p>This chapter will discuss C++ programs, and look at how to execute these on a PLCnext Control device.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="c-programs"><a class="header" href="#c-programs">C++ Programs</a></h2>
<p>PLCnext runtime programs created in C++ must inherit from <code>ProgramBase</code>.</p>
<p>Program instances are created using a special type of PLCnext component. While standard ACF components are only required to inherit from <code>ComponentBase</code>, components that can create program instances must also inherit from <code>ProgramComponentBase</code>. The corresponding library singleton must also inherit from <code>ProgramLibraryBase</code>. When the PLCnext runtime starts, this library is loaded not by the ACF, but instead is loaded by the <a href="https://plcnext.help/te/Programming/Cplusplus/PLM_Program_Library_Manager.htm"><em>Program Library Manager</em></a> (PLM). The PLM creates non-real-time component instances in a similar way to the ACF, but it also has the ability to create instances of real-time programs.</p>
<p>A high-level comparison of the ACF and the PLM is given in the <a href="https://www.plcnext.help/te/PLCnext_Runtime/Managing_of_components.htm">PLCnext Technology Info Center</a>.</p>
<p>Like in the previous chapter, we can use the PLCnext CLI to generate a project template containing a C++ program:</p>
<ul>
<li>
<p>Create a new project on the host system:</p>
<p>$ plcncli new project --name MyProject --namespace MyNamespace --component MyComponent --program MyProgram --verbose</p>
<p>In this case we are using the PLCnext CLI template called <code>project</code>, whereas in the previous chapter we used the template called <code>acfproject</code>. You can also see that there is now a program name specified in the command along with the component name.</p>
</li>
<li>
<p>Set the build target for the project:</p>
<p>$ cd MyProject
$ plcncli set target --add --name AXCF2152 --version 2021.9</p>
</li>
<li>
<p>Edit the source code using your favourite editor.</p>
<p>You can see that the PLCnext CLI has created the following source and configuration files in the <code>MyProject</code> directory:</p>
<pre><code class="language-text">├── CMakeLists.txt
├── external
│   └── ADD_DEPENDENT_LIBRARIES_HERE.txt
├── plcnext.proj
└── src
    ├── MyComponent.cpp
    ├── MyComponent.hpp
    ├── MyProgram.cpp
    ├── MyProgram.hpp
</code></pre>
<p>This project now includes both component and program source files, and does not include a <code>.acf.config</code> file.</p>
</li>
<li>
<p>Look at the <code>MyComponent.cpp</code> and <code>MyComponent.cpp</code> files.</p>
<p>These files implement a <em>program component</em>, which looks quite similar to the ACF component you saw in the previous chapter. You can do almost everything in a program component that you can do in an ACF component, including declaring GDS port variables on the component.</p>
</li>
<li>
<p>Look at the <code>MyProgram.hpp</code> file.</p>
<p>You can see from the comments that it is possible to declare GDS port variables on a program. This means that program instances can have GDS ports, and those ports can be connected to GDS ports on other components and programs. Just like in the previous chapter, these GDS connections are specified in a <code>.gds.config</code> file.</p>
</li>
<li>
<p>Look at the <code>MyProgram.cpp</code> file.</p>
<p>The <code>Execute</code> method you see here will be called by a real-time task. That real-time task will be scheduled to run on one of the Execution and Synchronisation Manager (ESM) instances created by the PLCnext runtime. Every time the real-time task runs, the Execute method on all program instances in that real-time task will be executed in the order that those program instances appear in the task. If the task is a <em>cyclic</em> task, then the Execute method will be called at the period of the cyclic task.</p>
</li>
</ul>
<p>You can now go ahead and fill the Execute method with your real-time-dependent code.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="real-time-c-programming-guidelines"><a class="header" href="#real-time-c-programming-guidelines">Real-time C++ Programming Guidelines</a></h2>
<p>The Execute method in a C++ program must not contain any code that could compromise the strict deterministic performance of the system. The Execute method <em>must</em> complete within a &quot;reasonable&quot; period of time. This must be considered this when using time-consuming program constructs like loops.</p>
<p>Perhaps the most common mistake made in a developer's first real-time C++ program is to treat the <code>Execute</code> method like the <code>main</code> function in a C++ application, and include something like a <code>while(true)</code> loop in that method. Not only is this not necessary (the <code>Execute</code> method will be called at a fixed frequency from a cyclic task), this type of endless loop will immediately &quot;crash&quot; the PLC because the <code>Execute</code> method will never exit, and either the task watchdog timer or the system watchdog timer will be exceeded.</p>
<p>Here are some other tips for real-time C++ programming:</p>
<ul>
<li>
<p>Never allocate or re-allocate memory in the <code>Execute</code> method. e.g.</p>
<ul>
<li>don't use <code>malloc</code></li>
<li>don't use <code>new</code></li>
<li>don't assign a value to a string variable unless you know it will not result in memory re-allocation.</li>
<li>be careful when using classes like <code>std::vector</code>, since these can allocate memory automatically.</li>
</ul>
</li>
<li>
<p>Never use <code>std::mutex</code> in a real-time C++ program. If mutexes are required, use <code>Arp::Mutex</code>.</p>
</li>
<li>
<p>Don't use third-party code (e.g. libraries) if that code does any of the above. Since third-party code is generally not designed with these limitations in mind, this means it is very unlikely that you will be able to use any third-party code directly in a C++ program without modification.</p>
</li>
<li>
<p>Do not call methods on RSC services from the <code>Execute</code> method.</p>
</li>
</ul>
<p>To help make sure you keep within these guidelines:</p>
<ul>
<li>Perform all memory allocation in the program constructor, e.g. allocating memory for the maximum expected size of all string and vector variables.</li>
<li>Check any operations that might re-allocate memory in the <code>Execute</code> method (e.g. vector resizing).</li>
<li>Consider doing non-real time work in the component that is associated with the program, and use <code>Arp::Mutex</code> to synchronise variable access between the component and the program.</li>
<li>If in doubt, don't use third party code in the <code>Execute</code> method.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="building-and-deploying-a-real-time-c-application"><a class="header" href="#building-and-deploying-a-real-time-c-application">Building and Deploying a Real-time C++ Application</a></h2>
<p>Real-time C++ applications can be built using the PLCnext CLI, in a similar way to the ACF applications in the previous chapter:</p>
<ul>
<li>
<p>On the command-line, use the PLCnext CLI to generate the intermediate files for the project:</p>
<pre><code class="language-text">$ plcncli generate code --verbose
</code></pre>
</li>
<li>
<p>Generate the configuration files for the project:</p>
<pre><code class="language-text">$ plcncli generate config --verbose
</code></pre>
<p>This step - which is not required for ACF projects - creates configuration files that are used by the Program Library Manager.</p>
</li>
<li>
<p>Build the project:</p>
<pre><code class="language-text">$ plcncli build --verbose
</code></pre>
<p>This command uses CMake to build the project for all the specified targets.</p>
</li>
</ul>
<h3 id="deploying"><a class="header" href="#deploying">Deploying</a></h3>
<p>It is possible to deploy a real-time C++ project by copying binary and configuration files to specific directories on the target, in a similar way to the ACF projects in the previous chapter. This procedure, which is more complicated than for ACF projects, is described in the Github repository <a href="https://github.com/PLCnext/CppExamples/tree/master/Examples/NoEngineer"><em>PLM/ESM/GDS Configuration without PLCnext Engineer</em></a>.</p>
<p>There is a simpler way to generate the required configuration files and deploy them to the target, and that uses PLCnext Engineer software running on a Windows machine. To use your C++ project in PLCnext Engineer, it must be packaged as a PLCnext Engineer library. This can be done using the following PLCnext CLI command:</p>
<pre><code class="language-text">$ plcncli deploy --verbose
</code></pre>
<p>This will create a file with the extension <code>.pcwlx</code>, which is a PLCnext Engineer library file.</p>
<p>When this library is added to a PLCnext Engineer project, then the configuration of tasks, program instances and GDS port connections can all be done graphically in PLCnext Engineer. The complete project can also be deployed to the target from PLCnext Engineer. This process is described in a <a href="https://youtu.be/IUGSZzuzm-c?t=173">tutorial video</a> from Phoenix Contact.</p>
<p>If your project does not preclude the use of PLCnext Engineer, then this is the easiest way to configure and deploy a real-time C++ application to a PLCnext Control device.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="iec-61131-3-programs"><a class="header" href="#iec-61131-3-programs">IEC 61131-3 Programs</a></h2>
<p>In the previous section you saw how to deploy a real-time C++ project using PLCnext Engineer software.</p>
<p>Using PLCnext Engineer, it is also possible to write real-time programs in any or all of the four languages defined by the IEC 61131 standard - Ladder (LD), Function Block Diagram (FBD), Structured Text (ST) and Sequential Function Chart (SFC). Programs written in these languages run on the <a href="https://www.plcnext.help/te/Programming/Csharp/eCLR_Programming_System.htm">Embedded Common Language Runtime</a> (ECLR), and programs written in these languages can run alongside - and exchange GDS data with - real-time programs and components written in C++.</p>
<h3 id="eclr"><a class="header" href="#eclr">ECLR</a></h3>
<p>As the name suggests, the Embedded Common Language Runtime is based on <a href="https://docs.microsoft.com/en-us/dotnet/standard/clr">Microsoft's Common Language Runtime</a> (CLR), which is required to run C# and other .NET programs on Windows platforms. Unlike the CLR, the ECLR is specifically designed to run real-time, deterministic programs on embedded devices. The ECLR contains a sub-set of CLR libraries, along with specialised libraries added by Phoenix Contact.</p>
<p>Phoenix Contact provides a Visual Studio extension that helps write C# code that targets the ECLR. In this way, it is possible to write real-time programs, function blocks and functions in C#.</p>
<p>IEC 61131 and ECLR programming is outside the scope of this book, but there is plenty of information on these topics in the PLCnext Info Center.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-io"><a class="header" href="#configuring-io">Configuring I/O</a></h1>
<p>Now that you know more about the PLCnext runtime and how to write C++ applications for PLCnext Control devices, we can return to the question that was asked at the end of Chapter 1: <em>How can an application read and write inputs and outputs from/to the I/O modules attached to the PLCnext Control device?</em></p>
<p>The simplest way to do this is as follows:</p>
<ul>
<li>
<p>Using PLCnext Engineer software, create a new project for your target device and configure the I/O modules that are connected to the controller via Axioline, Interbus and/or Profinet. Send the PLCnext Engineer project to the PLC.</p>
</li>
<li>
<p>In PLCnext Engineer, take note of the names of the GDS ports that are automatically created for the channels on each I/O module.</p>
</li>
<li>
<p>In a <code>.gds.config</code> file, connect the GDS ports from the I/O modules to corresponding GDS ports on your ACF component(s) and/or real-time program(s).</p>
</li>
</ul>
<p>In this way, C++ components and programs can easily exchange data with field devices via the I/O modules attached to the PLCnext Control device.</p>
<h2 id="ioconf"><a class="header" href="#ioconf">IoConf</a></h2>
<p>If your application precludes the use of PLCnext Engineer for some reason, then it is possible to generate the same I/O configuration files that PLCnext Engineer creates using a .NET class library called IoConf. The use of this tool is demonstrated in a <a href="https://github.com/PLCnext/IOconf_Examples">tutorial on Github</a>.</p>
<h2 id="axioline-master-service"><a class="header" href="#axioline-master-service">Axioline Master service</a></h2>
<p>Another I/O configuration option is given in the <a href="https://github.com/PLCnext/BusConductor">Bus Conductor example</a> on Github. This solution is suitable when the precise I/O configuration is not known at design-time, or if the configuration must be changed dynamically at run-time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-programming-tools"><a class="header" href="#other-programming-tools">Other Programming Tools</a></h1>
<p>So far we have been using the PLCnext CLI from the command-line, and using an integrated development environment (IDE) like Visual Studio Code simply to edit source files.</p>
<p>For those who prefer to use either Visual Studio (on Windows) or Eclipse IDE (on Windows or Linux), Phoenix Contact provides the following tools with each PLCnext CLI installation:</p>
<ul>
<li>
<p>A PLCnext extension for Visual Studio (Windows only).</p>
</li>
<li>
<p>A PLCnext add-in for Eclipse IDE (Windows and Linux).</p>
</li>
</ul>
<p>By using these tools, it is possible to perform most PLCnext CLI functions from within the IDE.</p>
<p>As well as assisting with C++ development for PLCnext Control devices, the Visual Studio extension also includes tools for writing C# code that targets the ECLR.</p>
<p>The use of these tools is described extensively in the PLCnext Info Center, and will not be covered in this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extension-processes-in-cc"><a class="header" href="#extension-processes-in-cc">Extension Processes in C/C++</a></h1>
<p>You have seen how to use the Application Component Framework to extend the PLCnext runtime with your own components. By using the ACF, these components are integrated tightly with the PLCnext runtime, where they are treated in exactly the same way as factory-installed components.</p>
<p>It is also possible to extend the PLCnext runtime with extension <em>processes</em> (also called <em>External Function Extensions</em>).</p>
<p>A high-level comparison of extension components (internal function extensions) and extension processes (external function extensions) is given in the <a href="https://www.plcnext.help/te/PLCnext_Runtime/Function_extensions_for_internal_processes.htm">PLCnext Technology Info Center</a>.</p>
<p>Extension processes are useful for PLCnext Control functions that must be started and stopped with the PLCnext runtime - just like extension components - but that cannot or do not want to use the ACF. A typical example: When porting a third-party PLC runtime to the PLCnext Control platform, it may be impractical to re-design the source code into PLCnext runtime components.</p>
<p>One challenge faced by extension processes is that GDS ports cannot be created on extension process. So the question once again arises: <em>How can an extension process read and write inputs and outputs from/to the I/O modules attached to the PLCnext Control device?</em></p>
<p>You have already seen how to read and write GDS variable data using RSC services, and RSC services can also be used to (indirectly) access PLC I/O from any process running outside the PLCnext runtime. However, as discussed previously, RSC services are only suitable for non-real time applications, like ACF components. This solution may be fine for any extension process that does not require deterministic I/O access.</p>
<p>For more demanding applications, the PLCnext runtime provides a mechanism for extension processes to read and write PLC I/O in a deterministic way. This deterministic access to PLC I/O makes extension processes ideally suited to third-party runtimes like <a href="https://www.plcnextstore.com/permalinks/apps/latest/60002172000052">Codesys</a>, <a href="https://www.plcnextstore.com/permalinks/apps/latest/60002172000692">UAO Runtime</a> and <a href="https://www.eclipse.org/4diac/en_rte.php">4diac</a>. In this case the solution involves the use of an ANSI-C interface. This type of solution is described in detail in the <a href="https://github.com/PLCnext/SampleRuntime">Sample Runtime tutorial</a> on Github.</p>
<!--
TODO:

* (Add an extra step to Sample Runtime - just start the process, don't start the ANSI-C components).
* Answer questions from Jan-Willem about the block diagram - draw on earlier chapters.
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-next"><a class="header" href="#what-next">What Next</a></h1>
<ul>
<li>Revise what you've learned in this book.</li>
<li>Find out more about other parts of the PLCnext Technology ecosystem.</li>
<li>Get involved!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-big-picture"><a class="header" href="#the-big-picture">The Big Picture</a></h2>
<p>This book has covered almost every part of the PLCnext Control platform, including an extensive step-by-step exploration of the PLCnext runtime. At this stage, it is beneficial to zoom out and take a look at how all the pieces of the PLCnext Control platform fit together. One of the best ways to do this is to work through the interactive online course <a href="https://elearning.plcnext.help/PLCnTech_Basics/story.html"><em>PLCnext Technology Basics</em></a> on the PLCnext Community website. In addition to the topics covered in this book, the course will introduce you to the other parts of the PLCnext Technology Ecosystem, including PLCnext Engineer and <a href="https://www.plcnextstore.com">the PLCnext Store</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="get-involved"><a class="header" href="#get-involved">Get Involved!</a></h2>
<p>PLCnext Community. This includes a discussion forum and a Makers Blog, both of which are open to public contributions.</p>
<p>Github. Contribute to open-source projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-a-plcnext-control-programming-resources"><a class="header" href="#appendix-a-plcnext-control-programming-resources">Appendix A: PLCnext Control programming resources</a></h2>
<h3 id="general-development-guides"><a class="header" href="#general-development-guides">General Development Guides</a></h3>
<ul>
<li>
<p>Savushkin R&amp;D, Github project: <a href="https://github.com/savushkin-r-d/PLCnext-howto">PLCnext-howto</a></p>
</li>
<li>
<p>Phoenix Contact USA, Github project: <a href="https://github.com/plcnextusa/PLCnext-Guides">PLCnext-Guides</a></p>
</li>
</ul>
<h3 id="c-1"><a class="header" href="#c-1">C++</a></h3>
<ul>
<li>
<p>PLCnext Info Center - <a href="https://plcnext.help/te/Programming/Cplusplus/Cpp-programming.htm">C++ programming on PLCnext Technology</a>.</p>
</li>
<li>
<p>PLCnext Info Center - <a href="https://plcnext.help/te/Programming/Cplusplus/PLCnext_API_documentation.htm">PLCnext API documentation</a>.</p>
</li>
<li>
<p>PLCnext Technology Github projects:</p>
<ul>
<li>CppExamples. &quot;<a href="https://github.com/PLCnext/CppExamples">PLCnext/CppExamples</a>&quot;</li>
<li>Real Time DataLogger. &quot;<a href="https://github.com/PLCnext/PLCnext_RT_Datalogger">PLCnext/PLCnext_RT_Datalogger</a>&quot;</li>
<li>Bus Conductor. &quot;<a href="https://github.com/PLCnext/BusConductor">PLCnext/BusConductor</a>&quot;</li>
<li>SampleRuntime. &quot;<a href="https://github.com/PLCnext/SampleRuntime">PLCnext/SampleRuntime</a>&quot;</li>
</ul>
</li>
<li>
<p>Github project: &quot;<a href="https://github.com/sdurbin-pxc/plcnext-io-drivers-cpp">sdurbin-pxc/plcnext-io-drivers-cpp</a>&quot;.</p>
</li>
<li>
<p>Björn Sauer, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/how-to-use-visual-studio-code-to-write-c-for-plcnext/">How to use Visual Studio Code to write C++ for PLCnext</a>&quot;.</p>
</li>
<li>
<p>Björn Sauer, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/automate-your-development-workflow-with-visual-studio-code/">Automate your development workflow with Visual Studio Code</a>&quot;.</p>
</li>
<li>
<p>Github project: &quot;<a href="https://github.com/savushkin-r-d/PLCnext-howto/tree/master/HowTo%20install%20Linux%20(Ubuntu)%20tools%20for%20C%2B%2B%20programming%20with%20Eclipse%20IDE">How to configure Eclipse® to program and crosscompile for the AXC F 2152 on Ubuntu 18.04 LTS</a>&quot;.</p>
</li>
<li>
<p>Martin Boers, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/how-to-include-an-open-source-library-in-your-own-c-project/">How to include an open-source library in your own C++ project</a>&quot;.</p>
</li>
<li>
<p>Nils Hettig, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/how-to-store-data-in-sqlite-in-a-plcnext-c-project/">How to store data in SQLite in a PLCnext C++ project</a>&quot;.</p>
</li>
<li>
<p>Damian Bombeeck, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/how-to-install-libcurl-on-your-axc-f-2152-controller/">How to install libcurl on your AXC F 2152 controller</a>&quot;.</p>
</li>
<li>
<p>Damian Bombeeck, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/tutorial-using-the-axc-f-2152-controller-with-microsoft-azure/">Tutorial: Using the AXC F 2152 controller with Microsoft Azure</a>&quot;.</p>
</li>
<li>
<p>Oliver Warneke, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/connecting-plcnext-plcs-to-remote-rs232-rs485-via-pseudo-tty/">Connecting PLCnext PLCs to remote RS232/RS485 via pseudo TTY</a>&quot;.</p>
</li>
<li>
<p>Björn Sauer, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/use-the-ixmlserializable-interface-to-populate-a-class-from-a-xml-file/">Use the IXMLSerializable interface to populate a class from a XML file</a>&quot;.</p>
</li>
<li>
<p>Björn Sauer, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/how-to-define-complex-gds-ports-and-connect-them-to-gds-port-in-iec-code/">How to define complex GDS Ports and connect them to GDS Port in IEC code</a>&quot;.</p>
</li>
<li>
<p>Peer Michael Gaus, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/pugixml-a-light-weight-xml-processing-library-with-xpath-support/">pugixml a light-weight XML processing library with XPATH support</a>&quot;.</p>
</li>
<li>
<p>Peer Michael Gaus, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/linq-the-list-processing-library-for-c/">Linq the list processing library for C++</a>&quot;.</p>
</li>
<li>
<p>Peer Michael Gaus, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/c-testing-with-catch2/">c++ testing with catch2</a>&quot;.</p>
</li>
</ul>
<h3 id="rust-1"><a class="header" href="#rust-1">Rust</a></h3>
<ul>
<li>PLCnext Technology - Rust Sample Runtime. &quot;<a href="https://github.com/PLCnext/rust-sample-runtime">PLCnext/rust-sample-runtime</a>&quot;</li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<ul>
<li>
<p>PLCnext Technology - Docker and Balena Engine: &quot;<a href="https://github.com/PLCnext/Docker_GettingStarted">PLCnext/Docker_GettingStarted</a>&quot;.</p>
</li>
<li>
<p>Martin Boers, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/how-to-turn-an-axc-f-2152-into-an-aws-greengrass-device/">How to turn an AXC F 2152 into an AWS Greengrass device</a>&quot;.</p>
</li>
</ul>
<h3 id="java"><a class="header" href="#java">Java</a></h3>
<ul>
<li>Marcel Luhmann, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/java-application-on-an-axc-f-2152/">Java Application on AXC F 2152</a>&quot;.</li>
</ul>
<h3 id="nodejs-and-node-red"><a class="header" href="#nodejs-and-node-red">Node.js and Node-Red</a></h3>
<ul>
<li>
<p>Stijn Noppe, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/install-node-red-and-pm2-offline/">Install Node-RED and PM2 offline</a>&quot;</p>
</li>
<li>
<p>Stijn Noppe, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/installing-node-js-on-rfc-4072s/">Installing Node.js on RFC 4072S</a>&quot;.</p>
</li>
<li>
<p>Dries Van Laerhoven, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/node-red-and-getting-started-with-docker/">Node-RED and getting started with Docker</a>&quot;.</p>
</li>
<li>
<p>Stefan Brinkmann, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/node-red-with-docker-tips-and-best-practice/">Node-Red with docker tips and best practice</a>&quot;.</p>
</li>
<li>
<p>Github project: &quot;<a href="https://github.com/plcnextusa/node-red">plcnextusa/node-red</a>&quot;.</p>
</li>
<li>
<p>Damian Bombeeck, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/tutorial-using-the-axc-f-2152-controller-with-microsoft-azure/">How to connect PLCnext to Microsoft® Azure® by Node.js SDK</a>&quot;.</p>
</li>
<li>
<p>Nodejs package for communicating with a Phoenix Contact TC Router: &quot;<a href="https://github.com/PhoenixContactUSA/node-tcrouter">PhoenixContactUSA/node-tcrouter</a>&quot;.</p>
</li>
<li>
<p>Node-red nodes for communicating with a Phoenix Contact TC Router: &quot;<a href="https://github.com/PhoenixContactUSA/node-red-contrib-tcrouter">PhoenixContactUSA/node-red-contrib-tcrouter</a>&quot;</p>
</li>
<li>
<p>Michel Schneider, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/how-to-send-a-mail-via-node-red/">How to send a mail via Node-Red</a>&quot;.</p>
</li>
<li>
<p>Stijn Noppe, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/knx-opc-ua-gateway-with-node-red/">KNX - OPC UA Gateway with Node-Red</a>&quot;.</p>
</li>
<li>
<p>Michel Schneider, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/how-to-create-a-simple-mqtt-broker-on-the-axc-f-2152-with-node-red/">How to create a simple MQTT broker on the AXC F 2152 with Node-Red</a>&quot;.</p>
</li>
</ul>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<ul>
<li>
<p>Python-Startersguide. &quot;<a href="https://github.com/pxcbe/python-startersguide">pxcbe/python-startersguide</a>&quot;.</p>
</li>
<li>
<p>Nils Hettig, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/read-and-write-plc-process-data-with-python/">Read and Write PLC Process Data with Python</a>&quot;</p>
</li>
<li>
<p>Stijn Noppe, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/installing-pip-without-ipkg/">Installing PIP without IPKG</a>&quot;.</p>
</li>
<li>
<p>Nils Hettig, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/install-miniconda-on-plcnext-devices/">Install Miniconda on PLCnext Devices</a>&quot;.</p>
</li>
<li>
<p>Yuri Chamarelli, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/modbus-tcp-with-python-on-axc-f-2152/">Modbus TCP with Python on AXC F 2152</a>&quot;.</p>
</li>
<li>
<p>Github project: aiohttp for AXCF2152 (2020.0). &quot;<a href="https://github.com/Songyantao-PXCCN/aiohttp/tree/master/2020.0">Songyantao-PXCCN/aiohttp</a>&quot;.</p>
</li>
<li>
<p>Github project: PLCnext connection to the REST api. &quot;<a href="https://github.com/dclark3774/PythonRESTapi">dclark3774/PythonRESTapi</a>&quot;.</p>
</li>
<li>
<p>Alexander Skachkov, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/a-simple-rest-based-library-to-use-variables-in-plcnext-axc-f-2152-plc-from-python/">A simple REST based library to use variables in PLCnext AXC F 2152 PLC from Python</a>&quot;.</p>
</li>
<li>
<p>Frederik Leempoels, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/use-plcnext-to-wakeonlan-wol-your-pc/">Use PLCnext to WakeOnLan (WoL) Your PC</a>&quot;.</p>
</li>
<li>
<p>Dries Van Laerhoven, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/opencv-python-red-light-detection-on-plcnext/">OpenCV - Python, Red Light detection on PLCnext</a>&quot;.</p>
</li>
<li>
<p>Dries Van Laerhoven, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/machine-learning-on-plcnext/">Machine Learning on PLCnext</a>&quot;.</p>
</li>
</ul>
<h3 id="c-2"><a class="header" href="#c-2">C#</a></h3>
<ul>
<li>
<p>Martin Boers, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/how-to-create-a-simple-plcnext-console-application-in-c/">How to create a simple PLCnext console application in C#</a>&quot;</p>
</li>
<li>
<p>Björn Sauer, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/install-the-net-core-runtime-3-0-0-on-the-axc-f-2152/">Install the .NET Core runtime 3.0.0 on the AXC F 2152</a>&quot;.</p>
</li>
<li>
<p>Kay Suttkuss, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/getting-started-with-c-and-net-core-3-0-on-plcnext/">Getting started with C# and .Net Core 3.0 on PLCnext</a>&quot;.</p>
</li>
<li>
<p>Kay Suttkuss, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/remote-debugging-of-a-net-core-application-with-vs-code-on-plcnext/">Remote Debugging of a .Net Core application with VS Code on PLCnext</a>&quot;.</p>
</li>
</ul>
<h3 id="go"><a class="header" href="#go">Go</a></h3>
<ul>
<li>
<p>Dries Van Laerhoven, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/getting-started-with-go-on-plcnext/">Getting started with Go on PLCnext</a>&quot;.</p>
</li>
<li>
<p>Dries Van Laerhoven, PLCnext Community Makers Blog post: &quot;<a href="https://www.plcnext-community.net/makersblog/serving-static-files-with-go/">Serving static files with Go</a>&quot;.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="appendix-b-list-of-rsc-services"><a class="header" href="#appendix-b-list-of-rsc-services">Appendix B: List of RSC Services</a></h2>
<p>A complete list of public RSC services is available in the <a href="https://www.plcnext.help/te/Communication_interfaces/Remote_Service_Calls_RSC/RSC_documentation_reference.htm">PLCnext Info Center</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
